<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CLBHDS</title>
  
  
  <link href="https://bipch.cn/atom.xml" rel="self"/>
  
  <link href="https://bipch.cn/"/>
  <updated>2021-11-17T06:31:54.645Z</updated>
  <id>https://bipch.cn/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的博客的建立</title>
    <link href="https://bipch.cn/my-blog/"/>
    <id>https://bipch.cn/my-blog/</id>
    <published>2021-11-17T01:19:15.000Z</published>
    <updated>2021-11-17T06:31:54.645Z</updated>
    
    <content type="html"><![CDATA[<p>了解这篇博客背后的技术堆栈，我们将明白 Next.js 界面的渲染，以及如何使用 MDX 解析 Mackdown 内容，并在文章中添加自定义组件，以及我如何组织我的代码库等等。</p><span id="more"></span><p>如果您一直在考虑为自己创建一个开发博客，那么您可能已经被工具和技术的数量所淹没。我们生活在一个富足的时代，有很多选择。</p><p>当我们建立自己的博客时，我的首要任务是找到一个解决方案，让我们在每篇文章中嵌入完全自定义的内容，如何将我们自定义组件通过 Mackdown 渲染呈现出。</p><p>下面简单分析出我的博客的工作原理，以便您可以为自己构建类似的内容。当然，博客当前正在改善，这也不是一个教程，但它应该为您提供一个广泛的路线图。</p><h2 id="The-stack"><a href="#The-stack" class="headerlink" title="The stack"></a>The stack</h2><p>首先博客是一个基于 <a href="https://nextjs.org/">Next.js</a> 框架的应用程序。</p><p>使用 Next，在界面构建方面有多种不同的选择，您可以选择每次请求时、或者静态站点生成时进行。为了获得更好的体验我选择在站点生成时提前构建所有博客文章。</p><p>在部署方面使用了由开发 Next.js 相同的公司，开发出来的 <a href="https://vercel.com/dashboard">Vercel</a>，一方面是因为其是同一个公司的产品，我认为它会得到很好的优化。并且在部署方面该平台也很棒。</p><p>在样式方面，主要使用的是 <a href="https://styled-components.com/">styled-components</a>，并从头开始编写所有样式。我不使用任何的像 antd、Bootstrap “装饰性”库是由于我并不想要网站有着特定的网站风格，与其千篇一律的保持一种风格不如我们根据自己的需求去封装。</p><p>对于一些博客中的动画，我们可以依赖 <a href="https://react-spring.io/">react-spring</a>，其能满足大部分 UI 相关的动画需求。</p><p>在 Mackdown 内容解析中，这是项目中最关键的部分，这里采用的是 <a href="https://mdxjs.com/">mdx</a> 进行 Mackdown 渲染，使用 <a href="https://www.npmjs.com/package/gray-matter">gray-matter</a> 解析 Mackdown 内容文档顶部定义键值对。</p><h2 id="MDX"><a href="#MDX" class="headerlink" title="MDX"></a>MDX</h2><p>MDX 是 Markdown 的扩展，不仅可以解析 Mackdown 标签，还可以解析 React 组件。</p><p>比如普通的 Mackdown 基础代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">This is another paragraph, with some **bold text**.</span><br><span class="line"></span><br><span class="line">Here&#x27;s an unordered list:</span><br><span class="line">- Apple</span><br><span class="line">- Banana</span><br><span class="line">- Carrot</span><br></pre></td></tr></table></figure><p>在 web 界面使用 Mackdown 时，需要一个 “转译” 步骤，将 Mackdown 转换为相对应的 HTML，以便浏览器可以理解。这些星号变成一个 strong 标签，列表变成一个 ul，每个段落都有一个 p 标签。</p><p>这很好，但这意味着我们仅限于 Markdown 知道的少数 HTML 元素。</p><p>MDX 将格式更进一步，并允许我们以 React 组件的形式包含我们自己的元素，比如官网给出的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PieChart <span class="keyword">from</span> <span class="string">&#x27;../components/PieChart&#x27;</span>;</span><br><span class="line">This paragraph introduces a **data visualization**:</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">PieChart</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">  <span class="attr">title</span>=<span class="string">&quot;Favourite foods&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">  <span class="attr">data</span>=<span class="string">&#123;[</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    &#123; <span class="attr">label:</span> &#x27;<span class="attr">Pizza</span>&#x27;, <span class="attr">value:</span> &#x27;<span class="attr">30</span>%&#x27; &#125;,</span></span></span><br><span class="line"><span class="tag"><span class="xml">    &#123; <span class="attr">label:</span> &#x27;<span class="attr">Broccoli</span>&#x27;, <span class="attr">value:</span> &#x27;<span class="attr">5</span>%&#x27; &#125;,</span></span></span><br><span class="line"><span class="tag"><span class="xml">    &#123; <span class="attr">label:</span> &#x27;<span class="attr">Haagen-Dasz</span>&#x27;, <span class="attr">value:</span> &#x27;<span class="attr">65</span>%&#x27; &#125;,</span></span></span><br><span class="line"><span class="tag"><span class="xml">  ]&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">/&gt;</span></span></span><br></pre></td></tr></table></figure><p>这会给程序员带来更多的想法，实际上，您在 React 应用程序中所做的任何事情现在都可以嵌入到您的博客文章中的任何位置。</p><h2 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h2><p>我们在博客文档中，不仅包含文章的具体内容，还可能包括，另外一些 “Metadata” 数据，比如 – 标题、摘要、日期等字段。</p><p>我这里使用了 <a href="https://github.com/jonschlinkert/gray-matter">gray-matter</a>，其是一个 Markdown 插件，可让我们在文档顶部定义键值对。</p><p>比如我们的文档可能是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: My Blog</span><br><span class="line">seoTitle: How I Built my Blog using MDX, Next.js, and React</span><br><span class="line">abstract: An in-depth look at the technical structure for my blog.</span><br><span class="line">isPublished: true</span><br><span class="line">date: 2021-04-20T09:15:00-0400</span><br><span class="line">layout: Article</span><br><span class="line">---</span><br><span class="line">(Actual blog post content here!)</span><br></pre></td></tr></table></figure><p>具体使用需要依靠 MDX 进行修改。</p><h2 id="获取文章列表"><a href="#获取文章列表" class="headerlink" title="获取文章列表"></a>获取文章列表</h2><p>由于我的博客内容都是存储在本地，那么我们可以使用 <code>getStaticProps</code> 方法，Next 允许我们在站点构建时，在站点部署之前做一些工作。我们可计算在那段时间内要在这些部分中显示的帖子列表。</p><p>比如代码会是这种样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/index.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Homepage</span>(<span class="params">&#123; newestContent, popularContent &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// content</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStaticProps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newestContent = <span class="keyword">await</span> getLatestContent(&#123; <span class="attr">limit</span>: <span class="number">20</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> popularContent = <span class="keyword">await</span> getPopularContent(&#123; <span class="attr">limit</span>: <span class="number">10</span> &#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123; newestContent, popularContent &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>getLatestContent</code> 是由自己封装的一种遍历本地文件系统以查找所有 <code>.mdx</code> 博客文章的方法。<br>逻辑看起来像是这样的：</p><ol><li>收集目录中的所有 MDX 文件，这里可以使用 <code>fs.readdirSync</code>。</li><li>使用 <a href="https://github.com/jonschlinkert/gray-matter">gray-matter</a> 解析 Mackdown 中的信息。</li><li>过滤掉所有未发布的帖子，我们可以添加 <code>isPublished</code> 标识是否发布，如果为 <code>true</code> 标识已发布。</li><li>对所有的文字根据 <code>date</code> 进行排序。</li><li>返回数据，前端渲染。</li></ol><p>当然这种开发方式看似非常的低级，但不得不承认它是非常有效的，这肯定是更多的工作，但它给了我很多控制权。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用自己的技术搭建博客，可以给我们带来更多的想法，也能为我们带来更好的体验。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;了解这篇博客背后的技术堆栈，我们将明白 Next.js 界面的渲染，以及如何使用 MDX 解析 Mackdown 内容，并在文章中添加自定义组件，以及我如何组织我的代码库等等。&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="https://bipch.cn/categories/React/"/>
    
    
    <category term="服务端渲染" scheme="https://bipch.cn/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装Jenkins</title>
    <link href="https://bipch.cn/docker-jenkins/"/>
    <id>https://bipch.cn/docker-jenkins/</id>
    <published>2021-11-10T21:22:15.000Z</published>
    <updated>2021-11-10T22:25:46.745Z</updated>
    
    <content type="html"><![CDATA[<p>Jenkins 是一款开源自动化服务器，提供了数百个插件来支持任何项目的构建、部署和自动化，可以让项目持续集成变成可能。</p><span id="more"></span><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>使用 <code>docker</code> 可以十分方便的构建我们的项目，这就就使用其官网推荐使用的 <code>jenkinsci/blueocean</code> 镜像，这里使用 <code>docker pull</code> 进行拉取：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> pull jenkinsci/blueocean</span><br></pre></td></tr></table></figure><p>下载完成后，可以查看 docker 所有镜像，看其是否存在：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY            <span class="keyword">TAG</span>                 <span class="title">IMAGE</span> ID            CREATED             SIZE</span><br><span class="line">jenkinsci/blueocean   latest              ffd223ae2d7b        <span class="number">11</span> hours ago        <span class="number">603M</span>B</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>既然镜像都已经下载完成了，我们可以依此运行 Jenkins 容器了，首先我们在宿主机上创建一个数据卷 <code>jenkins-data</code> 用于之后的数据持久化，防止数据因容器重启造成数据丢失，执行下面命令运行容器：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="string">\</span></span><br><span class="line">  --name jenkins-blueocean <span class="string">\</span></span><br><span class="line">  -d <span class="string">\</span></span><br><span class="line">  -p <span class="number">8080</span>:<span class="number">8080</span> <span class="string">\</span></span><br><span class="line">  -p <span class="number">50000</span>:<span class="number">50000</span> <span class="string">\</span></span><br><span class="line">  -v jenkins-data:/<span class="keyword">var</span>/jenkins_home <span class="string">\</span></span><br><span class="line">  jenkinsci/blueocean</span><br></pre></td></tr></table></figure><p>这样 <code>8080</code> 端口用来公开访问 Web 界面，<code>50000</code> 端口允许访问远程 Java (JIRA) API。</p><p>之后通过 <code>docker ps</code> 命令确认容器是否已经后台运行：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                                              NAMES</span><br><span class="line"><span class="number">2</span>b89a114fe97        jenkinsci<span class="regexp">/blueocean   &quot;/</span>sbin<span class="regexp">/tini -- /u</span>sr<span class="regexp">/…&quot;   About an hour ago   Up About an hour    0.0.0.0:8080-&gt;8080/</span>tcp, <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">50000</span>-&gt;<span class="number">50000</span>/tcp   jenkins-blueocean</span><br></pre></td></tr></table></figure><p>如果错误，可以使用：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> logs <span class="number">2</span>b<span class="number">89</span>a<span class="number">114</span>fe<span class="number">97</span></span><br></pre></td></tr></table></figure><p>查看容器运行的日志，分析错误。</p><h2 id="配置-Jenkins"><a href="#配置-Jenkins" class="headerlink" title="配置 Jenkins"></a>配置 Jenkins</h2><p>当一切运行正常之后，可以直接使用 <code>http://ip:8080</code> 进行访问 Jenkins 的 Web 界面。</p><p><strong>Step1：解锁 Jenkins。</strong></p><p><img data-src="https://img.bplink66.com/2021/11/10/umze4157ux.png" alt=""></p><p>我们进入容器中查看 <code>/var/jenkins_home/secrets/initialAdminPassword</code> 文件中的内容：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it <span class="number">2</span>b89a114fe97 <span class="regexp">/bin/</span>bash</span><br><span class="line">jenkins@<span class="number">2</span>b89a114fe97:<span class="regexp">/$ cat /</span>var<span class="regexp">/jenkins_home/</span>secrets/initialAdminPassword</span><br><span class="line">a6f6d08fcc4741756733001d1fc79be62</span><br></pre></td></tr></table></figure><p>将内容粘贴进去即可初始化。<br><strong>Step2：安装插件。</strong></p><p><img data-src="https://img.bplink66.com/2021/11/10/20dxr7zr9c1.png" alt=""></p><p>Jenkins 可以说完全由插件来驱动的，所以安装一些基础的插件是非要必要的，这里我们选择 安装推荐的插件 ，然后静静地等待插件安装完成即可。</p><p><strong>Step3：创建用户。</strong></p><p><img data-src="https://img.bplink66.com/2021/11/10/pe5e3vgz4.png" alt=""></p><p>根据自己需求添加配置即可。之后就可以看到首页界面，Jenkins 初始化配置过程也就完成了。之后就可以正式开启你的 持续集成&amp;持续部署 之旅！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Jenkins 是一款开源自动化服务器，提供了数百个插件来支持任何项目的构建、部署和自动化，可以让项目持续集成变成可能。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://bipch.cn/categories/Docker/"/>
    
    
    <category term="jenkins" scheme="https://bipch.cn/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装Gitea</title>
    <link href="https://bipch.cn/docker-gitea/"/>
    <id>https://bipch.cn/docker-gitea/</id>
    <published>2021-11-10T03:22:15.000Z</published>
    <updated>2021-11-10T18:25:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>Gitea 是一个用Go编写的社区管理的轻量级代码托管解决方案，虽然其在功能上和 <a href="https://about.gitlab.com/">Gitlab</a> 对比还是略显不足，但是其更加轻便灵巧，更适合用于搭建个人的服务器。</p><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>使用 <code>docker-compose</code> 可以很简单的搭建起整个项目，具体的配置可以看其官方的文档：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">gitea_net:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gitea_net</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gitea/gitea:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">USER_UID:</span> <span class="number">1000</span></span><br><span class="line">      <span class="attr">USER_GID:</span> <span class="number">1000</span></span><br><span class="line">      <span class="attr">DB_TYPE:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">DB_HOST:</span> <span class="string">db:3306</span></span><br><span class="line">      <span class="attr">DB_NAME:</span> <span class="string">$&#123;MYSQL_DATABASE&#125;</span></span><br><span class="line">      <span class="attr">DB_USER:</span> <span class="string">$&#123;MYSQL_USER&#125;</span></span><br><span class="line">      <span class="attr">DB_PASSWD:</span> <span class="string">$&#123;MYSQL_PASSWORD&#125;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitea_net</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./gitea:/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3222:3000&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;222:22&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.27</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">gitea-mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">$&#123;MYSQL_USER&#125;</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">$&#123;MYSQL_PASSWORD&#125;</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">$&#123;MYSQL_DATABASE&#125;</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitea_net</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql:/var/lib/mysql</span></span><br></pre></td></tr></table></figure><p>这样便已 mysql 的方式启动 Gitea，下面添加一个配置文件 <code>.env</code> 写入详细的配置信息：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">MYSQL_USER</span>=user</span><br><span class="line"><span class="attr">MYSQL_PASSWORD</span>=password</span><br><span class="line"><span class="attr">MYSQL_DATABASE</span>=gitea</span><br><span class="line"><span class="attr">MYSQL_ROOT_PASSWORD</span>=root-password</span><br></pre></td></tr></table></figure><p>这样我们执行下面的命令，启动整个项目：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --<span class="keyword">env</span>-<span class="keyword">file</span> .<span class="keyword">env</span> up -d</span><br></pre></td></tr></table></figure><p>之后添加一些简单的配置，然后注册管理员密码即可正常使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Gitea 是一个用Go编写的社区管理的轻量级代码托管解决方案，虽然其在功能上和 &lt;a href=&quot;https://about.gitlab.com/&quot;&gt;Gitlab&lt;/a&gt; 对比还是略显不足，但是其更加轻便灵巧，更适合用于搭建个人的服务器。&lt;/p&gt;
&lt;h2 id=&quot;doc</summary>
      
    
    
    
    <category term="Docker" scheme="https://bipch.cn/categories/Docker/"/>
    
    
    <category term="gitea" scheme="https://bipch.cn/tags/gitea/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装Loki</title>
    <link href="https://bipch.cn/docker-loki/"/>
    <id>https://bipch.cn/docker-loki/</id>
    <published>2021-11-10T03:22:15.000Z</published>
    <updated>2021-11-10T04:48:43.489Z</updated>
    
    <content type="html"><![CDATA[<p>Loki+Promtail+Grafana(简称LPG)是一套轻量级日志收集方案，既对内存要求很低，同时也有着不错的ui界面。</p><p>如果需要相关的日志收集功能，那么LPG是一款不错的选择。主要是因为其比较轻量级。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LPG不会对日志进行全文索引，而是为每个日志流设置一组标签。其核心便是下面几个组件：</p><ul><li><code>Promtail：</code>日志收集器，负责收集我们项目的日志，并把收集到的日志推送到Loki中去。</li><li><code>Loki：</code>聚合存储日志数据，可以作为Grafana的数据源，为Grafana提供可视化数据。</li><li><code>Grafana：</code>从Loki中获取日志信息，进行可视化展示。</li></ul><p><img data-src="https://img.bplink66.com/2021/11/10/2mu4oqcvjys.jpg" alt=""></p><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><p>这里是用 <code>docker-compose</code> 进行安装，我们添加 <code>docker-compose.yml</code> 文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">loki:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">loki:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">loki</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/loki:2.4.0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3100:3100&quot;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">-config.file=/etc/loki/local-config.yaml</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">loki</span></span><br><span class="line">  <span class="attr">promtail:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">promtail</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/promtail:2.4.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/disk/nginx/logs:/var/log:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./promtail/promtail.yaml:/etc/promtail/docker-config.yaml</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">-config.file=/etc/promtail/docker-config.yaml</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">loki</span></span><br><span class="line">  <span class="attr">grafana:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">grafana</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">grafana/grafana:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3001:3000&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">loki</span></span><br></pre></td></tr></table></figure><p>我们需要注意上面的数据卷路径，如果不存在请注意修改。<br>添加 <code>promtail.yaml</code> 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">http_listen_port:</span> <span class="number">9080</span></span><br><span class="line">  <span class="attr">grpc_listen_port:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">positions:</span></span><br><span class="line">  <span class="attr">filename:</span> <span class="string">/tmp/positions.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">clients:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">http://loki:3100/loki/api/v1/push</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">system</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">job:</span> <span class="string">varlogs</span></span><br><span class="line">        <span class="attr">__path__:</span> <span class="string">/var/log/*log</span></span><br></pre></td></tr></table></figure><p>其是我们收集日志的一些配置，我们直接使用默认的即可。<br>最后使用 docker-compose 命令进行启动：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker-compose up -d</span></span><br></pre></td></tr></table></figure><h2 id="配置Grafand"><a href="#配置Grafand" class="headerlink" title="配置Grafand"></a>配置Grafand</h2><ol><li>运行成功后访问 <a href="http://ip:3000">http://ip:3000</a> 登录Grafana，账号密码为<code>admin:admin</code>，然后重置我们的密码。</li><li>登录成功后添加Loki数据源。</li></ol><p><img data-src="https://img.bplink66.com/2021/11/10/2g1jn3wsmwq.png" alt=""></p><ol start="3"><li>之后设置 Loki 访问地址 <a href="http://loki:3100">http://loki:3100</a> ，进行测试连接。</li></ol><p><img data-src="https://img.bplink66.com/2021/11/10/zyeanolkm6.png" alt=""></p><ol start="4"><li>接下来在Explore选择Loki，并输入查询表达式（Loki query）为 <code>&#123;filename=&quot;/var/log/access.log&quot;&#125;</code></li></ol><p><img data-src="https://img.bplink66.com/2021/11/10/1l0yp33p6my.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LPG日志收集方案确实非常轻量级，性能也不错！不过如果你有对日志有着更高需求还是换种方案比较好。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Loki+Promtail+Grafana(简称LPG)是一套轻量级日志收集方案，既对内存要求很低，同时也有着不错的ui界面。&lt;/p&gt;
&lt;p&gt;如果需要相关的日志收集功能，那么LPG是一款不错的选择。主要是因为其比较轻量级。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://bipch.cn/categories/Docker/"/>
    
    
    <category term="loki" scheme="https://bipch.cn/tags/loki/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装Bitwarden</title>
    <link href="https://bipch.cn/docker-bitwarden/"/>
    <id>https://bipch.cn/docker-bitwarden/</id>
    <published>2021-11-07T04:10:10.000Z</published>
    <updated>2021-11-10T05:12:09.951Z</updated>
    
    <content type="html"><![CDATA[<p>Bitwarden 是一个免费的开源密码管理器，可将网站凭据等敏感信息存储在加密的保险库中，并可以为网站根据自定义规则生成随机密码。具体使用可以看其 <a href="https://github.com/bitwarden">github仓库</a>。</p><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这里直接使用 docker-compose 安装，如果没有安装 docker 可以先安装这些插件。<br>安装完成之后添加 <code>docker-compose.yml</code> 文件：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># docker-compose.yml</span><br><span class="line"><span class="keyword">version</span>: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">service<span class="variable">s:</span></span><br><span class="line">  bitwarden:</span><br><span class="line">    image: bitwardenrs/server</span><br><span class="line">    restar<span class="variable">t:</span> always</span><br><span class="line">    port<span class="variable">s:</span></span><br><span class="line">      - <span class="number">8000</span>:<span class="number">80</span></span><br><span class="line">    volume<span class="variable">s:</span></span><br><span class="line">      - ./<span class="keyword">bw</span>-dat<span class="variable">a:</span>/data</span><br><span class="line">    environmen<span class="variable">t:</span></span><br><span class="line">      WEBSOCKET_ENABLED: <span class="string">&#x27;true&#x27;</span> # Required <span class="keyword">to</span> use websockets</span><br><span class="line">      SIGNUPS_ALLOWED: <span class="string">&#x27;true&#x27;</span>   # <span class="keyword">set</span> <span class="keyword">to</span> false <span class="keyword">to</span> disable signups</span><br></pre></td></tr></table></figure><p>这样就能使用 docker 管理 bitwardenrs 镜像了，它更快、更可靠，并且它是完全开源的，并且使用率很高。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>文件编写完成后，我们可以使用下面的简单代码运行它：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker-compose up -d</span></span><br></pre></td></tr></table></figure><p>之后访问 <a href="http://ip:8000">http://ip:8000</a> 路径，就能正常访问了。</p><p>为了密码的安全性，我们也可以将 <code>SIGNUPS_ALLOWED</code> 修改为 false，禁止匿名用户注册：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># docker-compose.yml</span><br><span class="line">version: &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  bitwarden:</span><br><span class="line">    image: bitwardenrs/server</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 8000:80</span><br><span class="line">    volumes:</span><br><span class="line">      - ./bw-data:/data</span><br><span class="line">    environment:</span><br><span class="line">      WEBSOCKET_ENABLED: &#x27;true&#x27; # Required to use websockets</span><br><span class="line"><span class="addition">+      SIGNUPS_ALLOWED: &#x27;false&#x27;   # set to false to disable signups</span></span><br></pre></td></tr></table></figure><p>修改完成后，我们需要重启正在运行的 docker 镜像：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose <span class="meta">down</span></span><br><span class="line">docker-compose <span class="meta">up</span> -d</span><br></pre></td></tr></table></figure><p>之后我们在进行注册，会出现下面错误：</p><p><img data-src="https://img.bplink66.com/2021/11/10/263j3ijmsv7.png" alt=""></p><p>这样注册功能便已经禁用了，项目可以更安全的保护存储的密码等私密信息。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Bitwarden 是一个免费的开源密码管理器，可将网站凭据等敏感信息存储在加密的保险库中，并可以为网站根据自定义规则生成随机密码。具体使用可以看其 &lt;a href=&quot;https://github.com/bitwarden&quot;&gt;github仓库&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://bipch.cn/categories/Docker/"/>
    
    
    <category term="bitwarden" scheme="https://bipch.cn/tags/bitwarden/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染过程</title>
    <link href="https://bipch.cn/browser/"/>
    <id>https://bipch.cn/browser/</id>
    <published>2021-08-27T15:55:42.000Z</published>
    <updated>2021-11-08T14:21:12.014Z</updated>
    
    <content type="html"><![CDATA[<p>当浏览器接收到用户请求指定网站时，会先从服务器请求所需的HTML、CSS、javascript、image等资源资源，然后经历解析、构建树、渲染布局、绘制等一系列流程，最终渲染为用户看到的界面。尽管市面上的浏览器五花八门但是其渲染网页的流程大抵是相同的。</p><span id="more"></span><h2 id="渲染路径"><a href="#渲染路径" class="headerlink" title="渲染路径"></a>渲染路径</h2><p>浏览器从接收到用户请求到界面渲染完成等一系列流程可以称呼为 <code>关键渲染路径</code>。<br>关键渲染路径主要包含着两个阶段：页面内容加载完成和页面资源加载完成，分别对应 <code>DOMContentLoaded</code> 和 <code>Load</code>：</p><ul><li><code>DOMContentLoaded</code> 当 DOM 加载完成触发(不包括样式表，图片)。</li><li><code>load</code> 只有界面中所有资源比如DOM、样式表、脚本、图片都已加载完成后触发。</li></ul><p>浏览器渲染的过程主要包括以下五步：</p><ol><li>浏览器请求到 HTML 文档，并解析为 DOM 树。</li><li>处理 CSS 标记，并构建为层叠样式表模型 CSSOM(<code>CSS Object Model</code>)。</li><li>将得到的 DOM 和 CSSOM 合并，得到一个渲染树(<code>rendering tree</code>)，代表被渲染的对象。</li><li>根据渲染树节点属性计算其在界面上的位置生成最终的渲染树，这一步称之为布局 <code>layout</code>。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。</li><li>将最终将渲染树的各个节点绘制到屏幕上，这一步被称为绘制 <code>painting</code>。</li></ol><p>当然上述步骤并不是同步完成，比如 1、2 步骤便是并发执行的，同时也不一定一次性顺序完成，比如 DOM 或 CSSOM 被修改时，浏览器可能会重复执行某些过程，这样才能计算出哪些元素需要在屏幕上进行重新渲染。</p><p><img data-src="https://img.bplink66.com/2021/11/08/2cp0x728w4s.png" alt="webkit渲染引擎流程"></p><h2 id="浏览器渲染网页具体流程"><a href="#浏览器渲染网页具体流程" class="headerlink" title="浏览器渲染网页具体流程"></a>浏览器渲染网页具体流程</h2><h3 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h3><p>当浏览器接收到服务器端返回的 HTML 文档，会解析文档并生成DOM树。<br>但是有几点需要注意：</p><ul><li>DOM 树在构建过程中可能会被 CSS 和 JS 的加载而阻塞。</li><li><code>display: none</code> 隐藏的元素也会在 DOM 树中。</li><li>注释内容也会存在 DOM 树中。</li><li><code>&lt;script&gt;</code> 标签也会挂载在 DOM 节点上。</li></ul><p>无论是构建 DOM 还是 CSSOM 都会经过下面的过程：</p><p><img data-src="https://img.bplink66.com/2021/11/08/21rka8i2dce.jpg" alt=""></p><p>当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。</p><h3 id="构建CSSOM规则树"><a href="#构建CSSOM规则树" class="headerlink" title="构建CSSOM规则树"></a>构建CSSOM规则树</h3><p>浏览器根据服务器返回的 CSS 构建为 CSSOM，每个 CSS 文件都被分析成一个 StyleSheet 对象，每个对象都包含CSS规则。CSS 规则对象包含对应于 CSS 语法的选择器和声明对象以及其他对象。<br>在这个过程需要注意的是：</p><ul><li>CSS 解析与 DOM 解析同步进行。</li><li>CSS 解析与 <code>&lt;script&gt;</code> 解析互斥，因为 script 中的代码可能会修改 CSS 的值。</li></ul><h3 id="Render-Tree"><a href="#Render-Tree" class="headerlink" title="Render Tree"></a>Render Tree</h3><p>合并上述步骤得到的 DOM树 和 CSS树，合并的结果称之为树渲染树。浏览器会先从 DOM树 的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的 CSS 样式规则并应用。<br>在这个过程需要注意的是：</p><ul><li>Render Tree != DOM Tree。</li><li><code>display: none</code> 的元素不在 Render Tree 中。</li><li><code>visibility: hidden</code> 的元素在 Render Tree 中。</li></ul><p><img data-src="https://img.bplink66.com/2021/11/08/2jhlytjrrh6.png" alt=""></p><p>此时虽然已有渲染树，但其不具备节点的位置信息，所以不能将其渲染到界面上，这就需要 Layout 进行计算了。</p><h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p>此阶段会对渲染树的各个节点进行遍历，由于渲染树的每个节点都是一个 Render Object 对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。</p><p>在这个过程需要注意的是：</p><ul><li><code>float</code> 元素，<code>absoulte</code> 元素，<code>fixed</code> 元素会发生位置偏移。</li><li>通常中的脱离文档流，其实就是脱离 Render Tree。</li></ul><h3 id="render-tree"><a href="#render-tree" class="headerlink" title="render tree"></a>render tree</h3><p>绘制阶段，浏览器会先遍历最终渲染树，最终根据渲染节点的属性绘制到界面上。至于怎么进行渲染是由浏览器的 UI 后端组件完成的，并不需要用户关心。</p><h2 id="渲染网页的那些事儿"><a href="#渲染网页的那些事儿" class="headerlink" title="渲染网页的那些事儿"></a>渲染网页的那些事儿</h2><h3 id="浏览器主要结构"><a href="#浏览器主要结构" class="headerlink" title="浏览器主要结构"></a>浏览器主要结构</h3><p><img data-src="https://img.bplink66.com/2021/11/08/hjjcg737g6.png" alt=""></p><p>其中渲染引擎是这篇重点，而常用的渲染引擎有两个：webkit 和 Gecko。<br>Firefox 使用 Geoko 引擎，Mozilla 自主研发的渲染引擎。Safari 和 Chrome 都使用 webkit，其是一款很好用的开源渲染引擎。虽然主流浏览器渲染过程叫法有区别，但是主要流程还是相同的。</p><h3 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h3><p>由于 JS 操作不仅可以操作 DOM 的结构，还可以操作 CSSOM 结构，这就会导致浏览器在遇到 <code>&lt;script&gt;</code> 标签时，DOM构建将暂停，直至脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。我们可以在 <code>script</code> 标签上增加属性 <code>async</code> 属性表示为异步操作。脚本解析会将脚本中改变 DOM 和 CSS 的地方分别解析出来，追加到 DOM树 和 CSSOM 规则树上。</p><p>每次去执行 JS 脚本都会严重地阻塞 DOM树 的构建，如果 JS 脚本还操作了 CSSOM，而正好这个 CSSOM 还没有构建，浏览器甚至会延迟脚本执行和构建 DOM，直至完成其 CSSOM 的下载和构建。所以，script 标签的位置很重要。</p><p>JS阻塞了构建 DOM树，也阻塞了其后的构建 CSSOM规则树，整个解析进程必须等待 JS 的执行完成才能够继续，这就是所谓的<strong>JS阻塞页面</strong>。</p><p>由于 CSSOM 负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM 是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM 和 DOM 的解析完全结束，浏览器才会进入下一步的渲染，这就是<strong>CSS阻塞渲染</strong>。</p><p>CSS 阻塞渲染意味着，在 CSSOM 完备前，页面将一直处理白屏状态，这就是为什么样式放在 head 中，仅仅是为了更快的解析 CSS，保证更快的首次渲染。</p><p>需要注意的是，CSSOM 具有一些默认的样式，所以即便你没有给页面任何的样式声明，CSSOM 依然根据浏览器规则生成默认的信息。</p><h2 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h2><p>由于 HTML 默认是流式布局的，但 CSS 和 JS 会打破这种布局，改变 DOM 的外观样式以及大小和位置。因此我们就需要知道两个概念：<code>replaint</code> 和 <code>reflow</code>。</p><h3 id="回流（reflow）"><a href="#回流（reflow）" class="headerlink" title="回流（reflow）"></a>回流（reflow）</h3><p>当浏览器发现布局发生了变化，这个时候就需要倒回去重新渲染，这个回退的过程叫 <code>reflow</code>。<code>reflow</code> 会从<code>html</code>这个<code>root frame</code>开始递归往下，依次计算所有的结点几何尺寸和位置，以确认是渲染树的一部分发生变化还是整个渲染树。<code>reflow</code> 几乎是无法避免的，因为只要用户进行交互操作，就势必会发生页面的一部分的重新渲染，且通常我们也无法预估浏览器到底会 <code>reflow</code> 哪一部分的代码，因为他们会相互影响。</p><h3 id="重绘（repaint）"><a href="#重绘（repaint）" class="headerlink" title="重绘（repaint）"></a>重绘（repaint）</h3><p>当我们修改一些背景色、文字颜色、边框色等不影响布局的属性时，界面中的一部分要重画，但界面的布局不会发生任何变化这便是<code>repaint</code>。</p><h3 id="reflow-和-repaint"><a href="#reflow-和-repaint" class="headerlink" title="reflow 和 repaint"></a>reflow 和 repaint</h3><p>综上所述在性能上 <code>repaint</code> 远高于 <code>reflow</code>，所以能够使用 <code>repaint</code> 尽量不使用 <code>reflow</code>。</p><p>比如 <code>display: none</code> 时界面布局会变化，所以 <code>reflow</code> 会被触发，但是 <code>visibility: hidden</code> 只会隐藏元素，但元素仍然占据着布局空间，所以其只会触发 <code>repaint</code> 不会触发 <code>reflow</code>，因为界面布局没有任何变化。</p><p>当元素的样式被修改时，浏览器并不会立刻 <code>reflow</code> 或 <code>repaint</code> 一次，而是会把这样的操作积攒一批，然后做一次 <code>reflow</code>，这又叫 <code>异步reflow</code> 或 <code>增量异步reflow</code>。但是在有些情况下，比如 <code>resize</code> 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 <code>reflow</code>。</p><h3 id="减少reflow、repaint触发次数"><a href="#减少reflow、repaint触发次数" class="headerlink" title="减少reflow、repaint触发次数"></a>减少reflow、repaint触发次数</h3><ul><li>用 <code>transform</code> 做形变和位移可以减少 <code>reflow</code>。</li><li>避免逐个修改节点样式，尽量一次性修改。</li><li>使用 <code>DocumentFragment</code> 创建虚拟 DOM，最终一次性通过 <code>append</code> 插入到真实 DOM 中。</li><li>可以将需要多次修改的 DOM 元素设置 <code>display: none</code>，操作完再显示(因为隐藏元素不在 <code>render</code> 树中，因此修改隐藏元素不会触发回流重绘)。</li></ul><p>通过上面的方式可以有效降低 <code>repaint</code> 触发次数，从而优化界面界面响应速度，增加用户体验。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/e6252dc9be32">浏览器渲染原理与过程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;当浏览器接收到用户请求指定网站时，会先从服务器请求所需的HTML、CSS、javascript、image等资源资源，然后经历解析、构建树、渲染布局、绘制等一系列流程，最终渲染为用户看到的界面。尽管市面上的浏览器五花八门但是其渲染网页的流程大抵是相同的。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://bipch.cn/categories/JavaScript/"/>
    
    
    <category term="浏览器" scheme="https://bipch.cn/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>mocha单元测试</title>
    <link href="https://bipch.cn/mocha/"/>
    <id>https://bipch.cn/mocha/</id>
    <published>2021-08-27T15:48:20.000Z</published>
    <updated>2021-11-08T17:12:03.024Z</updated>
    
    <content type="html"><![CDATA[<p>测试是一个项目周期里必不可少的环节，开发者在开发过程中也是无时无刻进行”人工测试”，如果每次修改一点代码，都要牵一发动全身都要手动测试关联接口，这样就禁锢了我们生产力。为了解放大部分测试生产力，相关的测试框架应运而生，而 <code>Mocha</code> 便是 JavaScript 或 Node 中比较流行的测试框架之一。</p><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先确定使用的测试框架：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev mocha chai supertest</span><br></pre></td></tr></table></figure><ul><li><code>mocha</code>：一款经典的 JavaScript 单元测试框架，详细配置可以看 <a href="https://github.com/mochajs/mocha">官网</a>。</li><li><code>chai</code>：一款经典的类断言的断言库，其能逻辑断言结果和类型。</li><li><code>supertest</code>：node 服务 fluent API 测试。</li></ul><p>你也可能使用其他的技术进行断言，但是测试流程大同小异。</p><h2 id="mocha-chai"><a href="#mocha-chai" class="headerlink" title="mocha + chai"></a>mocha + chai</h2><p>我们可以通过简单的例子进行了解 mocha + chai 的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chai.test.js</span></span><br><span class="line"><span class="keyword">const</span> chai = <span class="built_in">require</span>(<span class="string">&#x27;chai&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> expect = chai.expect;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;describe test&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;chai test&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 数值断言</span></span><br><span class="line">    expect(<span class="number">1</span> + <span class="number">1</span>).to.be.equal(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 类型断言</span></span><br><span class="line">    expect(<span class="number">1</span> + <span class="number">1</span>).to.be.a(<span class="string">&#x27;number&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之后执行命令进行断言：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npx mocha chai.test.js</span><br><span class="line">  describe test</span><br><span class="line">    ✔ chai test</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span> passing (5ms)</span><br></pre></td></tr></table></figure><p><code>describe</code> 方法用于开启一个测试例集，里面可以多个 <code>it</code> 方法，每个 <code>it</code> 都表示一个测试函数，它们都属于 mocha 中提供的全局方法。使用 <a href="https://www.npmjs.com/package/chai">chai</a> 插件库，可以进行数据或者类型断言，这两个可以完美的进行配合。</p><h2 id="mocha-supertest"><a href="#mocha-supertest" class="headerlink" title="mocha + supertest"></a>mocha + supertest</h2><p>node 服务 fluent API 测试插件库，详细的使用可以看官网 <a href="https://github.com/visionmedia/supertest">supertest</a>。</p><p>其不仅可以测试一些 api 借口，还能完美的和 koa 或者 express 结合进行 http api 进行测试。</p><p>比如下面代码让其和 koa 进行结合，测试其 api 的安全性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&#x27;supertest&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">data</span>: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;describe test&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">&#x27;chai test&#x27;</span>, <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    request(app.listen())</span><br><span class="line">      .get(<span class="string">&#x27;/user&#x27;</span>)</span><br><span class="line">      .expect(<span class="number">200</span>, done)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样便使用 <code>supertest</code> 传入 koa 实例的对象，可以用于断言 api 接口的返回数据和接口返回的 http 状态码。</p><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p>除了上面测试方式之外，mocha.js 还提供了四个钩子函数before、after、beforeEach、afterEach，来控制代码执行顺序：</p><ul><li><code>before</code>：将会在所有测试用例执行之前运行；</li><li><code>after</code>：则会在所有测试执行之后运行；</li><li><code>beforeEach</code>：将会在每个测试用例执行前执行；</li><li><code>afterEach</code>：将会在每个测试用例之后执行。</li></ul><p>我们使用下面代码，测试钩子的执行顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">&#x27;hooks&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;before&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;after&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;beforeEach&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  afterEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;afterEach&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  it(<span class="string">&quot;test hooks&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;it&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后我们运行命令，会得出下面的结果：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">before</span></span><br><span class="line">beforeEach</span><br><span class="line"><span class="keyword">it</span></span><br><span class="line">    √ test hooks</span><br><span class="line">afterEach</span><br><span class="line"><span class="keyword">after</span></span><br></pre></td></tr></table></figure><p>所以 Hooks 的最终执行顺序为： <code>before</code> &gt; <code>beforeEach</code> &gt; <code>describe</code> &gt; <code>afterEach</code> &gt; <code>after</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然测试文件的编写起来看似很麻烦，但当我们测试文件完成后，在以后不管是开发还是维护都会给我们带来极大的便利，同时也会极大的降低项目的的 bug，解放开发者的生产力。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;测试是一个项目周期里必不可少的环节，开发者在开发过程中也是无时无刻进行”人工测试”，如果每次修改一点代码，都要牵一发动全身都要手动测试关联接口，这样就禁锢了我们生产力。为了解放大部分测试生产力，相关的测试框架应运而生，而 &lt;code&gt;Mocha&lt;/code&gt; 便是 JavaScript 或 Node 中比较流行的测试框架之一。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://bipch.cn/categories/JavaScript/"/>
    
    
    <category term="Koa2" scheme="https://bipch.cn/tags/Koa2/"/>
    
    <category term="mocha" scheme="https://bipch.cn/tags/mocha/"/>
    
  </entry>
  
  <entry>
    <title>小程序获取登录用户信息</title>
    <link href="https://bipch.cn/xcx-user-info/"/>
    <id>https://bipch.cn/xcx-user-info/</id>
    <published>2021-08-27T15:47:42.000Z</published>
    <updated>2021-11-08T18:03:13.836Z</updated>
    
    <content type="html"><![CDATA[<p>小程序开发中可以通过微信官方提供的登录能力很方便地获取微信提供的用户身份标识，我们可以通过标识快速将项目与小程序内的用户体系进行关联。并且官网也有提供了一系列的登陆流程，可以看 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">官方文档</a>。</p><span id="more"></span><h2 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h2><p>我们梳理官方提供的流程图如下：</p><p><img data-src="https://img.bplink66.com/2021/11/05/1rmgind2mj2.jpg" alt=""></p><p>我们只需注意前面几个步骤：</p><ul><li>先调用 <code>wx.login</code> 方法，获取到临时登陆的凭证code。</li><li>然后通过 <code>wx.request</code>，将获取到的 code 传递到我们的后台服务。</li><li>后台服务通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html">auth.code2Session</a> 方式，将 <strong>appid</strong> + <strong>secret</strong> + <strong>code</strong> 一并传入即可。</li><li>后台在请求成功后，可以获取到 session_key 和 openId 等关键信息；其中 session_key 是微信服务器根据用户数据进行加密签名的密钥，我们只能保存在服务端，不能将其回传至客户端，主要为了防止用户敏感数据丢失。openId 为小程序用户的唯一标识，该标识是确定的，不会进行改变。</li><li>后台通过 Token 或者 Session 方式进行存储，并返回前端一个用户凭证 token。</li><li>前端通过对 token 进行存储，并且每次请求都带上这些字段。</li><li>后台服务每次都验证 token 的安全性，判断是否登陆过，或者是否被篡改，并做出相关的反应，并返回给前端。</li></ul><h2 id="获取-openID"><a href="#获取-openID" class="headerlink" title="获取 openID"></a>获取 openID</h2><p>我们可以通过，小程序提供的 <code>wx.login</code> 方法，获取小程序的登陆凭证 code，传递给服务端并在服务端与微信接口服务换取到 openid、unionid、session_key 等字段信息，具体可以参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html">官方文档</a>。</p><h3 id="wx-login"><a href="#wx-login" class="headerlink" title="wx.login"></a>wx.login</h3><p>我们可以在任何一个逻辑代码中调用此方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取用户唯一凭证</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="attr">login</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  wx.login(&#123;</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;获取登录 Code：&#x27;</span> + data.code);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fail</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>(<span class="string">&#x27;登录获取Code失败！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当获取到用户登录凭证后，就可以服务端使用 code 换取 openid、unionid、session_key 等信息了，而不再前段换取主要为了防止敏感数据被抓包。</p><h3 id="服务端代码处理"><a href="#服务端代码处理" class="headerlink" title="服务端代码处理"></a>服务端代码处理</h3><p>服务端接收前端传递过来的登陆凭证code，然后通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html">auth.code2Session</a> 方式获取关键信息。<br>比如我通过 Node 中的 <code>https</code> 模块进行换取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">https.get(<span class="string">`https://api.weixin.qq.com/sns/jscode2session?appid=<span class="subst">$&#123; appid&#125;</span>&amp;secret=<span class="subst">$&#123; secret&#125;</span>&amp;js_code=<span class="subst">$&#123; code&#125;</span>&amp;grant_type=<span class="subst">$&#123; grant_type&#125;</span>`</span>, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> body = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  res.setEncoding(<span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">  res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</span><br><span class="line">    body = body + d;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  res.on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    body = <span class="built_in">JSON</span>.parse(body);</span><br><span class="line">    <span class="keyword">if</span>(body.errcode === <span class="number">0</span> || body.errcode === <span class="literal">undefined</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(body);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(body.errmsg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当换取数据成功后，就可以获取到 session_key 与 openid 字段；其中 session_key 为签名密钥，我们不能将其返回给前端，只能保存到后端，以防泄露。而 openid 则是用户在小程序中的唯一标识，我们可以使用此字段和我们的项目进行关联。</p><h2 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h2><p>小程序可以通过各种前端接口获取微信提供的开放数据，获取微信提供的开放数据(只有基础信息，不含有任何敏感信息)，具体也可以阅读 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/button.html">官方的文档</a><br>可以使用一个简单的 <code>Button</code> 组件，设置 <code>open-type</code> 属性，使用 <code>bindgetuserinfo</code> 绑定获取用户信息方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">&quot;getUserInfo&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;zh_CN&quot;</span> <span class="attr">bindgetuserinfo</span>=<span class="string">&quot;userLogin&quot;</span>&gt;</span>获取用户信息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除此之外，我们可以在 userLogin 方法中写入下面内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取用户信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="attr">userLogin</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.detail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用 <code>wx.getUserInfo</code> 方法直接来获取，其作用是相同的。</p><h3 id="完整性校验"><a href="#完整性校验" class="headerlink" title="完整性校验"></a>完整性校验</h3><p>虽然我们可以通过这些方式获取到用户信息，但为了数据安全性，微信会对开放数据做签名和加密处理。开发者后台拿到开放数据后可以对数据进行校验签名和解密，依次来保证数据不被篡改。</p><p><img data-src="https://img.bplink66.com/2021/11/05/2pw0kku4vmc.jpg" alt=""></p><p>签名校验以及数据加解密涉及用户的会话密钥 session_key。 需先通过 <code>wx.login</code> 登录流程获取会话密钥 session_key 并保存在服务器。</p><ol><li>通过 <code>wx.getUserInfo</code> 或者 <code>Button</code> 获取数据，数据中会包含 rawData、signature 字段，其中 signature = sha1(rawData + session_key)。</li><li>开发者需要把 signature、rawData 传递给服务器进行验证，服务器通过 session_key 经过相同的加密方法，得出一个新的计算签名，我们将其命名为 signature2，最后对比 signature 与 signature2 即可验证数据的完整性。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html">小程序登录</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html">开放数据校验与解密</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;小程序开发中可以通过微信官方提供的登录能力很方便地获取微信提供的用户身份标识，我们可以通过标识快速将项目与小程序内的用户体系进行关联。并且官网也有提供了一系列的登陆流程，可以看 &lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="小程序" scheme="https://bipch.cn/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="openID" scheme="https://bipch.cn/tags/openID/"/>
    
  </entry>
  
  <entry>
    <title>JWT 令牌构建身份验证</title>
    <link href="https://bipch.cn/node-jwt/"/>
    <id>https://bipch.cn/node-jwt/</id>
    <published>2021-08-27T13:31:23.000Z</published>
    <updated>2021-11-08T19:06:33.766Z</updated>
    
    <content type="html"><![CDATA[<p>由于 http 是无状态的，所以你的程序必须能通过某种手段识别访问的用户，而这些技术便称之为 <code>session实现</code>，注意虽然名称为 <code>session实现</code> 但是其和 session 之间其实关系不大。</p><span id="more"></span><h2 id="session实现"><a href="#session实现" class="headerlink" title="session实现"></a>session实现</h2><p>用于区分 http 访问用户的手段统称为 session 的实现，比如早期将用户信息存储到 session 中，并将 session id 返回给前段，前段后面的每次请求都加上这些字段用于区分用户，但是由于不同电脑之间 session 很难通信，并且对本机内存消耗也会造成极大消耗，也不利于数据的集群。</p><p>后来又便出现了其他的 session 实现，比如：<code>token + redis</code> 或者 <code>jwt</code>，都是现在比较流行的技术。</p><p>其中 <a href="https://jwt.io/introduction">jwt</a> 优点便是去中心化，存储和识别用户不需要操作任何数据库，后台不需要存储任何信息，用户认证成功后通过指定密钥加密标识字段，生成一个 JWT 字符串并返回给前端，之后每次请求都需要携带 JWT，由后台对 JWT 进行解析验证，便能区分用户了。</p><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>JWT 数据由三部分组成，它们之间用圆点(.)连接。这三部分分别是：</p><ul><li>Header</li><li>Payload</li><li>Signature</li></ul><p>比如一个典型的 JWT 是这个样子：</p><blockquote><p>xxxxx.yyyyy.zzzzz</p></blockquote><p>我们分析下其各个部分的组成：<br><code>Header</code>：Header 部分也是主要有两部分组成，一个是：token 的类型(jwt)，另一个为：加密算法(比如：HMAC SHA256或者RSA等)。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过 Base64 对 JWT 的第一部分解码就能得到上面数据 。</p><p><code>Payload</code>：它包含着加密时定义的数据其他的配置信息。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;iat&quot;</span>: <span class="number">1516239022</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过 Base64 对 JWT 的第二部分解码就能得到上面数据。</p><p><code>Signature</code>：签名部分，为了校验数据在传递过程中有没有被更改。会根据 header 中指定的算法以及 payload、和一个秘钥拼接得到一个签名。由于秘钥并不会在网络中传输，所以客户端无法伪造一个 JWT(当然你一定要保存好秘钥)。</p><p>或许你还不太了解，我们结合官网例子 <a href="https://jwt.io/#debugger-io">jwt.io</a> 来看：</p><p><img data-src="https://cdn.bplink66.com/2021/08/29/qek3x31sod.png" alt=""></p><p>但是有一点需要注意 <strong>payload 和 Header 都是明文加密的，一定不要在 payload 中保存关键数据</strong>；就拿官网的例子来说，JWT 字符串为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure><p>我们拿第二段去 <a href="https://www.qqxiuzi.cn/bianma/base64.htm">Base64 解码</a>：</p><p><img data-src="https://img.bplink66.com/2021/11/05/178pdryx7ud.png" alt=""></p><p>可以看到数据被完全解密出来，当然我们只能看到数据，因为 Signature 的存在，只要密钥没有泄露其就能确保被包装数据是不能篡改，但其不能保证加密的数据不泄露，所以一般只用其加密一些标识，而不能用于加密私密数据。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>JWT 最大的优点便是去中心化，加密和认证的整个过程都不需要数据库，所以其不管是服务器集群还是节省服务器内存等都有着不错的表现。</p><p>但其缺点也很明显，因为其整个过程没有经过数据库，所以之前看似很简单的功能，现在却比较难以实现，比如退出登录、冻结账户等操作，由于这些都需要数据库的支持，而 jwt 一旦颁发，在有效期内其是一直生效的，无法将其废弃的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于 http 是无状态的，所以你的程序必须能通过某种手段识别访问的用户，而这些技术便称之为 &lt;code&gt;session实现&lt;/code&gt;，注意虽然名称为 &lt;code&gt;session实现&lt;/code&gt; 但是其和 session 之间其实关系不大。&lt;/p&gt;</summary>
    
    
    
    <category term="Node" scheme="https://bipch.cn/categories/Node/"/>
    
    
    <category term="jwt" scheme="https://bipch.cn/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>koa2探究http缓存</title>
    <link href="https://bipch.cn/koa-http/"/>
    <id>https://bipch.cn/koa-http/</id>
    <published>2021-08-25T04:40:13.000Z</published>
    <updated>2021-11-09T03:58:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>http 缓存是一种常见的 web 性能优化的手段，它可以大大的减少客户端和服务器之间的数据传输，了解其基础的概念后，我们可以使用 koa2 作为后台服务器，进行 http 缓存测试，这可以使我们更加深入了解到前后端 http 缓存是如何进行的，以及后台怎么判断文件缓存是否生效的。</p><span id="more"></span><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><p>三军未动，粮草先行，首先我们安装下所需依赖：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">yarn <span class="builtin-name">add</span> koa md5 koa-router mime</span><br><span class="line">yarn <span class="builtin-name">add</span> nodemon --dev</span><br></pre></td></tr></table></figure><p>依赖安装后在 <code>package.json</code> 配置启动命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">​    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;nodemon ./src/index.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令和依赖配置完成，我们还需初始化项目的架构：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http-<span class="keyword">cache</span></span><br><span class="line"><span class="keyword"></span>├── node_modules</span><br><span class="line">├── package-lock.<span class="keyword">json</span></span><br><span class="line"><span class="keyword"></span>├── package.<span class="keyword">json</span></span><br><span class="line"><span class="keyword"></span>├── src</span><br><span class="line">│   └── assets   <span class="comment"># 进行缓存的测试文件</span></span><br><span class="line">│         │── index.css</span><br><span class="line">│         └── <span class="number">231</span>n7a4spdu.png</span><br><span class="line">│   └── pages    <span class="comment"># 访问的界面</span></span><br><span class="line">│         └── index.html</span><br><span class="line">│   └── index.<span class="keyword">js </span><span class="comment"># 项目入口文件</span></span><br></pre></td></tr></table></figure><p>由于是为了实现 http缓存，所以不用太多复杂架构，代码也非常的简单，这里只简单贴下 index.js 入口文件中的内容，我们在其中添加配置和注册路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">&#x27;mime&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; readFileSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; join &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.type = mime.getType(<span class="string">&#x27;html&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> content = readFileSync(join(__dirname, <span class="string">&#x27;./page/index.html&#x27;</span>), <span class="string">&#x27;UTF-8&#x27;</span>);</span><br><span class="line">  ctx.body = content;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="regexp">/\.(css)$/</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; path &#125; = ctx;</span><br><span class="line">  ctx.type = mime.getType(<span class="string">&#x27;css&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> content = readFileSync(join(__dirname, <span class="string">&#x27;./assets&#x27;</span>, path), <span class="string">&#x27;UTF-8&#x27;</span>);</span><br><span class="line">  ctx.body = content;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="regexp">/\.(png)$/</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; path &#125; = ctx;</span><br><span class="line">  ctx.type = mime.getType(<span class="string">&#x27;png&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> imageBuffer = readFileSync(join(__dirname, <span class="string">&#x27;./assets&#x27;</span>, path));</span><br><span class="line">  ctx.body = imageBuffer;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app</span><br><span class="line">  .use(router.routes())</span><br><span class="line">  .use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="string">&quot;8888&quot;</span>, <span class="string">&quot;localhost&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">​    <span class="built_in">console</span>.log(<span class="string">&#x27;localhost app started at port 8888...&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">​    <span class="built_in">console</span>.error(error)</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>简单注册了几个 koa2 路由，通过 readFileSync 读取指定文件，然后不进行任何处理返回给前端，当我们访问指定文件时，按下 F12 会看到：</p><p><img data-src="https://img.bplink66.com/2021/11/09/2ib2nlvsib0.png" alt=""></p><p>此时项目资源都未开启缓存，即使刷新界面也是得出相同的结果。</p><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>在 http缓存 中最重要的便是 <code>response header</code> 中 <code>Cache-Control</code> 属性的配置了，比如我们添加下面的代码为图片文件开启 http缓存：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.get(/\.(png)$/, async (ctx) =&gt; &#123;</span><br><span class="line">  const &#123; path &#125; = ctx;</span><br><span class="line">  ctx.type = mime.getType(&#x27;png&#x27;);</span><br><span class="line">\+  ctx.set(&quot;Cache-Control&quot;, &#x27;max-age=60&#x27;);</span><br><span class="line">  const imageBuffer = readFileSync(join(__dirname, &#x27;./assets&#x27;, path));</span><br><span class="line">  ctx.body = imageBuffer;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们只是在 <code>response header</code> 中添加了一个属性，然后清空界面缓存重新请求界面，首次并没有变化，但第二次以后请求时会出现下面结果：</p><p><img data-src="https://img.bplink66.com/2021/11/09/itm9ng2xhu.png" alt=""></p><p>可以看出，图片已经被缓存，其大小为 memory cache，并且 Time 为 0，表示未和服务器通信；而其他的请求还是和之前一样。</p><p>但是我们的强缓存设置日期为 60s，当日期超过之后，刷新界面会发现文件又会进行重新请求，之后重新对该资源进行强缓存。</p><p>强缓存除了 <code>Cache-Control</code> 还有个 <code>Pragma</code> 属性，其值只有 <code>no-cache</code> 属性，表示<strong><em>不</em></strong>进行强缓存。其是为了向下兼容 <code>Cache-Control</code>，两个属性冲突时 Pragma 属性的优先级高于 Cache-Control，大家可以自行测试，只需在 <code>response header</code> 上添加改属性即可。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存和强缓存不同，其每次都会和服务端进行通信，由服务器端判断资源是否被修改，如果没有被修改则返回 304，否则返回 200 以及最新的资源。</p><p>比如还是给测试图片开启协商缓存：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> md5 = <span class="built_in">require</span>(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; readFileSync, statSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">router.get(<span class="regexp">/\.(png)$/</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; path &#125; = ctx;</span><br><span class="line">  ctx.type = mime.getType(<span class="string">&#x27;png&#x27;</span>);</span><br><span class="line">  <span class="comment">// 关闭强缓存</span></span><br><span class="line">  ctx.set(<span class="string">&#x27;pragma&#x27;</span>, <span class="string">&#x27;no-cache&#x27;</span>);</span><br><span class="line">  ctx.set(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;no-cache&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> imagePath = join(__dirname, <span class="string">&#x27;./assets&#x27;</span>, path);</span><br><span class="line">  <span class="keyword">const</span> imageBuffer = readFileSync(imagePath);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ETag/If-None-Match</span></span><br><span class="line">  <span class="keyword">const</span> eTag = md5(imageBuffer);</span><br><span class="line">  <span class="keyword">const</span> ifNoneMatch = ctx.request.headers[<span class="string">&#x27;if-none-match&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Last-Modified/If-Modified-Since</span></span><br><span class="line">  <span class="keyword">const</span> imageStatus = statSync(imagePath);</span><br><span class="line">  <span class="keyword">const</span> ifModifiedSince = ctx.request.headers[<span class="string">&#x27;if-modified-since&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!!ifNoneMatch &amp;&amp; !!eTag &amp;&amp; ifNoneMatch === eTag) &#123;</span><br><span class="line">    ctx.status = <span class="number">304</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!!imageStatus &amp;&amp; !!ifModifiedSince &amp;&amp; imageStatus.mtime.toGMTString() === ifModifiedSince) &#123;</span><br><span class="line">    ctx.status = <span class="number">304</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(eTag)</span><br><span class="line">    ctx.set(<span class="string">&#x27;ETag&#x27;</span>, eTag);</span><br><span class="line">    ctx.set(<span class="string">&#x27;Last-Modified&#x27;</span>, imageStatus.mtime.toGMTString());</span><br><span class="line">    ctx.body = imageBuffer;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>协商缓存主要依靠 <code>ETag/If-None-Match</code> 和 <code>Last-Modified/If-Modified-Since</code>。其中 ETag 是文件的唯一标识，这里就使用了 <code>md5</code> 加密了文件生成字符串，一旦文件改变那么 md5 的字符串也会改变；而 Last-Modified 表示文件最后的一次修改时间，我们可以使用 fs 模块中的 statSync 方法。根据协商缓存约定，首先判断 ETag 是否相同，相同返回 304 结束，否则对比 Last-Modified 是否相同，不相同那么我们将最新的 ETag 和 Last-Modified 以及资源返回。</p><p>当我们第一次返回时，资源请求结构如下：</p><p><img data-src="https://img.bplink66.com/2021/11/09/1mwb9u8bg4i.png" alt=""></p><p>可以看到 <code>ETag</code> 和 <code>Last-Modified</code> 属性都已经设置完成了，当刷新界面时，资源请求结构如下：</p><p><img data-src="https://img.bplink66.com/2021/11/09/wpf6pjjq4j.png" alt=""></p><p>可以看出由于状态都没有发生改变，所以命中了协商缓存，返回的状态码为 304。而如果此时我们把图片替换，资源请求结构如下：</p><p><img data-src="https://img.bplink66.com/2021/11/09/1lbliurk4b0.png" alt=""></p><p>可以看出不管是 <code>ETag</code> 还是 <code>Last-Modified</code> 属性都已经发生了变化，并且后台也判断出资源已经发生了变化，返回了最新的资源与 200 的状态码。并且最新返回的资源也会被缓存，当再次刷新界面，也是返回 304 状态码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最终代码已上传至 <a href="https://github.com/bctnab/http-cache">github仓库</a>，虽然上述代码很简单不能在任何环境下使用，但是如果借此了解 http缓存，这些还是绰绰有余的，如果你熟悉了 http缓存 相关的知识，那么可以去更深入的了解 dns、以及 dns优化等知识。在前端项目优化中，http缓存 是一个最常用且最有效的方法，它可以大大的减少客户端和服务器之间的数据传输，加快客户端响应的速度，减少了服务器压力等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;http 缓存是一种常见的 web 性能优化的手段，它可以大大的减少客户端和服务器之间的数据传输，了解其基础的概念后，我们可以使用 koa2 作为后台服务器，进行 http 缓存测试，这可以使我们更加深入了解到前后端 http 缓存是如何进行的，以及后台怎么判断文件缓存是否生效的。&lt;/p&gt;</summary>
    
    
    
    <category term="Node" scheme="https://bipch.cn/categories/Node/"/>
    
    
    <category term="http缓存" scheme="https://bipch.cn/tags/http%E7%BC%93%E5%AD%98/"/>
    
    <category term="Koa2" scheme="https://bipch.cn/tags/Koa2/"/>
    
  </entry>
  
  <entry>
    <title>HTTP缓存</title>
    <link href="https://bipch.cn/http-cache/"/>
    <id>https://bipch.cn/http-cache/</id>
    <published>2021-03-25T06:04:53.000Z</published>
    <updated>2021-11-09T06:05:05.103Z</updated>
    
    <content type="html"><![CDATA[<p>前端的缓存大致分为两大类，一类是浏览器缓存、另一类为http缓存。浏览器缓存是浏览器对本身一些数据的缓存，而http缓存是浏览器对网络资源的缓存，从而降低与服务器之间的数据传输，加快了客户端响应的速度，减少了服务器压力等。</p><span id="more"></span><h2 id="什么是HTTP缓存-？"><a href="#什么是HTTP缓存-？" class="headerlink" title="什么是HTTP缓存 ？"></a>什么是HTTP缓存 ？</h2><p>http缓存指：每当客户端向服务器端请求资源时，都会先抵达客户端缓存，如果需求资源已请求过切被缓存，便从浏览器的缓存中获取该资源而不会重新请求服务器。</p><p>当然请求资源的形式一般都为 <code>get</code> 方式，而对于其它方式请求的资源是无能为力的，所以下面的请求缓存都是在 <code>get</code> 请求下发生的。</p><p>http缓存都是从第二次请求开始的。在我们第一次请求服务器时，服务器返回资源，并在 <code>respone header</code> 头中回传资源的缓存参数；第二次请求时，浏览器会先判断请求参数是否命中强缓存，命中就直接 200，否则就把请求参数加到 <code>request header</code> 头中传给服务器，看是否命中协商缓存，命中则返回 304，否则服务器会返回新的资源。</p><h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><p>http缓存根据是否需要向服务器发起请求来分类，可以分为 <code>强缓存</code> 与 <code>协商缓存</code>。根据是否可以被单个或者多个用户使用来分类，可分为共享缓存和私有缓存。而如果命中强缓存将不在和服务器产生交互，但协商缓存不管是否命中都会和服务器产生交互。</p><p><img data-src="https://img.bplink66.com/2021/11/09/omr7wwr7w0.jpg" alt=""></p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>在缓存数据未失效的情况下，会直接使用浏览器中的缓存数据，不会向服务器发送请求。下图为使用强缓存的一个图片：</p><p><img data-src="https://img.bplink66.com/2021/11/05/2nq15z24t0c.png" alt=""></p><p>可以看出 http code 会被设置为 200，size 为 memory cache，并且 Time 为 0，表示未和服务器通信。</p><h4 id="相关Header"><a href="#相关Header" class="headerlink" title="相关Header"></a>相关Header</h4><p>我们可以通过服务端在 <code>response header</code> 设置缓存相关的参数：</p><ul><li><strong>Pragma</strong>：<code>该属性在 HTTP 1.1 之后便废弃了</code>，有且只有一个值：<strong>no-cache</strong>；表示不进行强缓存，但是 <a href="#协商缓存">协商缓存</a> 依旧会触发。</li><li><strong>Cache-Control</strong>： <code>该属性只适用于 HTTP 1.1 之后</code>，值可以为：<ul><li><strong>no-cache</strong>：和上面的同理。</li><li><strong>no-store</strong>：不使用任何缓存。</li><li><strong>max-age</strong>：缓存时长，单位 s。(为 0 时会走 <a href="#协商缓存">协商缓存</a>)</li><li><strong>public/private</strong>：响应是否可以被多个用户使用。</li><li><strong>must-revalidate</strong>：和 <strong>no-cache</strong> 相似都是使用缓存之前必须向服务器对缓存资源进行验证。但不同的是：<strong>no-cache</strong> 并不会去管缓存时间是否过期，而 <strong>must-revalidate</strong> 如果缓存时间过期，是必须重新发起请求的。</li></ul></li><li><strong>Expires</strong><br><code>过时的产物，它的存在只是一种兼容性的写法</code>，用于描述过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。</li></ul><p>虽然属性好像很多但是：<code>Expires</code> 是过时的产物，其优先性是最低的。而 <code>Pragma</code> 则是 <code>Cache-Control</code> 在 HTTP 1.1 之前的兼容写法，仅作为与http的向后兼容而定义，但是如果 <code>Pragma</code> 生效为了兼容其优先级是高于 <code>Cache-Control</code> 的。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>第一次请求资源时，如果服务器返回资源 response header 并不包含强缓存的设置(即该资源不走强缓存)，那么后面继续请求时会和服务器进行协商，判断资源是否已经更新，若资源没有更新服务器会返回 <code>304</code> 状态码，告诉浏览器数据未变动使用缓存中的数据，这样减少了服务器压力，如果资源有更新则返回 <code>200</code> 状态码并将最新的资源一并返回。</p><h4 id="相关Header-1"><a href="#相关Header-1" class="headerlink" title="相关Header"></a>相关Header</h4><p>我们也可以通过服务端在 <code>response header</code> 设置缓存相关的参数：</p><ol><li><strong>ETag 和 If-None-Match</strong><br><code>Etag</code> 表示资源请求时的 <strong>唯一标识</strong>，默认使用 hash 算法，可精确判断资源是否被修改，只要资源有变化，Etag 就会重新生成。<br>当再次请求该资源时，会将上次的 Etag 值放到 <strong>request header</strong> 里的 <code>If-None-Match</code> 字段中。服务端接收后，会拿来跟该资源文件的 Etag 值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存。</li><li><strong>Last-Modified 和 If-Modified-Since</strong><br>Last-Modified 是该资源文件最后一次更改时间，服务器在 <strong>response header</strong> 里返回。<br>当再次请求该资源时，将值放到 <strong>request headr</strong> 里的 <code>If-Modified-Since</code> 中。如果相同则命中协商缓存。</li></ol><blockquote><p>在精确度上，Etag 要优于 Last-Modified，Last-Modified 的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度<br>在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash值。<br>在优先级上，服务器校验优先考虑 Etag。<br>所以，两者各有长短，互补。</p></blockquote><h2 id="缓存过程"><a href="#缓存过程" class="headerlink" title="缓存过程"></a>缓存过程</h2><ol><li>首次资源加载服务器返回 <code>200</code> 状态码和资源，浏览器将服务器返回的资源记录下来，并把 <strong>response header</strong> 中的数据(Cache-Control、Expires、ETag…)一并记录；</li><li>再次请求该资源时，先比较当前请求和上一次该资源 <code>200</code> 请求的<strong>时间差</strong>，与 Cache-Control 中的 max-age 对比，若小于表示没有过期，命中强缓存，不发请求直接从本地缓存读取该文件请求结束；否则请求服务器进入下一步；</li><li>服务器解析出 <strong>request headr</strong> 中携带的  If-None-Match 和 If-Modified-Since 属性；</li><li>优先对比 Etag，若经过比对发现资源没有修改，则命中协商缓存，返回 <code>304</code>；如果两个值不相同则表示有变更，返回新的资源带上新的 Etag 值并返回 <code>200</code>；</li><li>如果服务器收到的请求没有 Etag 值，则以 If-Modified 进行比对，一致则命中协商缓存，返回304；不一致则返回新的 last-modified 和文件并返回 <code>200</code>；</li></ol><p>将上述流程绘制为流程图则如下：</p><p><img data-src="https://img.bplink66.com/2021/11/09/ezdi4ni90q.jpg" alt=""></p><h2 id="如何不使用缓存"><a href="#如何不使用缓存" class="headerlink" title="如何不使用缓存"></a>如何不使用缓存</h2><p>虽然http缓存可以大大的减少客户端和服务器之间的数据传输，加快了客户端响应的速度，减少了服务器压力等好处；但并不是所有文件都可以使用缓存，对比需要频繁修改的文件，我们使用缓存只会造成性能的浪费，对于频繁修改的文件我们一般禁止浏览器进行缓存：</p><ol><li><strong>Cache-Control</strong><br>缓存相关的配置，如果禁止缓存，可以将其设置为 <code>no-store</code> 表示禁止一切缓存。</li><li><strong>Expires</strong><br>上面介绍过，其表示缓存过期时间，但是此值已被遗弃，如果您项目支持此值，可以将其设置为历史时间，但需要注意其优先度极低，很容易被覆盖。</li><li><strong>hash 或 随机数</strong><br>缓存会先判断该资源是否被请求过，而如果我们在每个资源后面都加上 hash 值 或 随机数，这样由于资源名称一直在改变导致缓存也是无效的。</li></ol><h2 id="用户对地址栏的控制"><a href="#用户对地址栏的控制" class="headerlink" title="用户对地址栏的控制"></a>用户对地址栏的控制</h2><h3 id="输入-url-访问"><a href="#输入-url-访问" class="headerlink" title="输入 url 访问"></a>输入 url 访问</h3><p>此种方式属于正常的用户行为，将会触发浏览器缓存机制 【浏览器发起请求，按照正常流程，本地检查是否过期，或者服务器检查新鲜度，最后返回内容】</p><h3 id="F5"><a href="#F5" class="headerlink" title="F5"></a>F5</h3><p>浏览器会设置 max-age=0，跳过强缓存判断，会进行协商缓存判断，也就意味着其结果要么是 <code>304</code> 或者 <code>200</code>。</p><h3 id="ctrl-F5"><a href="#ctrl-F5" class="headerlink" title="ctrl+F5"></a>ctrl+F5</h3><p>跳过任何缓存，重新拉取最新的资源。返回的结果一定为 200。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ul><li><a href="/koa-http">koa2探究http缓存</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/227cee9c8d15">一文读懂http缓存</a></li><li><a href="https://zhuanlan.zhihu.com/p/58685072">HTTP 缓存机制</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端的缓存大致分为两大类，一类是浏览器缓存、另一类为http缓存。浏览器缓存是浏览器对本身一些数据的缓存，而http缓存是浏览器对网络资源的缓存，从而降低与服务器之间的数据传输，加快了客户端响应的速度，减少了服务器压力等。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://bipch.cn/categories/JavaScript/"/>
    
    
    <category term="http缓存" scheme="https://bipch.cn/tags/http%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>有趣面试问题</title>
    <link href="https://bipch.cn/interview/"/>
    <id>https://bipch.cn/interview/</id>
    <published>2021-03-25T05:00:54.000Z</published>
    <updated>2021-04-01T16:17:53.442Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些有趣平时又不轻易能刷到的一些问题，会持续进行更新。</p><span id="more"></span><h2 id="2021-03-25"><a href="#2021-03-25" class="headerlink" title="2021-03-25"></a>2021-03-25</h2><p>这次面试收获还是很大的，对各个知识点都进行了考察，由于公司大部分为 React 项目，所以并没有提问 Vue 相关知识。</p><h3 id="CSS中-伪类-和-伪元素-作用"><a href="#CSS中-伪类-和-伪元素-作用" class="headerlink" title="CSS中 伪类 和 伪元素 作用"></a>CSS中 伪类 和 伪元素 作用</h3><p><strong>伪元素</strong> 通用用于在文字之前或之后嵌入新的内容，或者设置首字母或首行的样式。例如常用的：<code>::after</code>(之后)、<code>::before</code>(之前)、<code>::selection</code>(选中)等。<br><strong>伪类</strong> 经常定义一些特殊样式，如果常用的<code>:hover</code>(鼠标移入)、<code>:focus</code>(获取到焦点)、<code>:not(selector)</code>(非 selector 元素)、<code>:nth-child(n)</code>(父元素的第 n 个子元素)等。</p><h3 id="content-box-和-border-box-有什么区别？"><a href="#content-box-和-border-box-有什么区别？" class="headerlink" title="content-box 和 border-box 有什么区别？"></a>content-box 和 border-box 有什么区别？</h3><p>听到这两个单词当时有些懵，不过还好反应过来了，都是<code>box-sizing</code>的属性，其作用就是告诉浏览器盒模型宽度和高度的计算规则。</p><ul><li><strong>content-box</strong>(默认)：标准 w3c 盒模型，<code>width = content</code>；</li><li><strong>border-box</strong>：另一种盒模型，包括内边距和边框都计算到宽度中，也就是<code>width = context + border + padding</code>。</li></ul><h3 id="垂直居中如何实现"><a href="#垂直居中如何实现" class="headerlink" title="垂直居中如何实现"></a>垂直居中如何实现</h3><p>说实话实现这种样式以及非常简单了：</p><ol><li>弹性布局(flex)；</li><li>如果父元素高度确定，使用 line-height；</li><li>兼容性比较好的方式，对元素使用 <strong>absolute</strong>，top、left 各 <strong>50%</strong>，然后使用 <strong>transform</strong> 上下各 <strong>负</strong> 高度一般(translate(-50%, -50%))；</li></ol><p>还有很多，就不多介绍了，方式属实太多。</p><h3 id="垂直居中后，如何向上偏移-20px"><a href="#垂直居中后，如何向上偏移-20px" class="headerlink" title="垂直居中后，如何向上偏移 20px"></a>垂直居中后，如何向上偏移 20px</h3><p>这一点属实挺搞人的，都垂直居中了还要进行偏移，实现方式也很多：</p><ol><li>利用 padding，直接内边距就行，不过需要注意盒模型的宽高计算方式，也就是 box-sizing 属性。</li><li>利用 transform 中的 translate 属性，该属性主要作用便是进行平移，比如我们可以这样些：translate(-50%, calc(-50% - 20px)) 续上面 -50% 后再垂直再 -20px 即可。</li></ol><h3 id="React-版本号代表什么？"><a href="#React-版本号代表什么？" class="headerlink" title="React 版本号代表什么？"></a>React 版本号代表什么？</h3><p>这一点真的没有注意到，回去之后第一时间进行了查询，原来还真有说法的，<a href="https://reactjs.bootcss.com/docs/faq-versioning.html">官网地址</a>。<br>版本号主要由 <strong>x.y.z</strong> 三部分组成。</p><ul><li>当出现严重 bug 并修复时，通过修改 <strong>z</strong> 来发布一个修订版本（如：15.6.2 至 15.6.3）。</li><li>当发布新功能 或 修复非严重 bug 时，通过修改 <strong>y</strong> 来发布一个次要版本（如：15.6.2 至 15.7.0）。</li><li>当发布破坏性更新时，通过修改 <strong>x</strong> 来发布一个主版本（如：15.6.2 至 16.0.0）。</li></ul><h3 id="React-中-“艾克藤死”-有什么作用？"><a href="#React-中-“艾克藤死”-有什么作用？" class="headerlink" title="React 中 “艾克藤死” 有什么作用？"></a>React 中 “艾克藤死” 有什么作用？</h3><p>说实话，当时面试官英语有些口音，导致我听到时，脑子一片空白，这是什么东西，让重读几次还是不确定，而马上到下一题时我脑子中突然出现一个单词<code>extends</code>，经过确认还真是。</p><p>当我们创建类组件时，必须继承<code>React.Component</code>或<code>React.PureComponent</code>任一个，两者区别不大，只是后者对<code>shouldComponentUpdate</code>进行浅对比。</p><p>至于为什么要继承它们，主要其内部为我们提供了生命周期钩子、setState、render等方法和 state、props 等属性，提供给我们调用和覆盖；在这些属性和方法中 render 方法至关重要，是<code>必须</code>要重写的，主要因为 React 中所有组件都是由 jsx 代码组成，此类型的代码可以当作 React virtul DOM 的语法糖，最终这些代码都需要 babel-loader 解析为类似于树状的 <strong>React virtul DOM</strong>(React 虚拟DOM)</p><p><img data-src="https://img.bipch.cn/2021/03/25/586c5c64d4ac6.png" alt=""></p><p>若此时并非第一次渲染，通过 diff 算法对比最新的 虚拟DOM树 和之前的 DOM树，找出经过修改的元素，最终形成一颗新的 virtul DOM 树，最后将这个 DOM树 渲染到客户端界面上，这样极大缩小了更新的 DOM 节点。</p><p>最后总结出一句话：不能不继承<code>React.Component</code>等去创建一个类组件，即使手动添加了 render 方法，因为 render 中所返回的 jsx 代码浏览器不能解析，必须通过 React 内部的转换。</p><h3 id="React-防止组件不必要的渲染"><a href="#React-防止组件不必要的渲染" class="headerlink" title="React 防止组件不必要的渲染"></a>React 防止组件不必要的渲染</h3><p>当时第一时间脱口而出<code>React.memo</code>，然后忘记了<code>React.PureComponent</code>，当然 PureComponent 只是进行了 <strong>shouldComponentUpdate</strong> 浅对比，真正要避免不必要的重复渲染还是要看 <strong>shouldComponentUpdate</strong> 的。</p><h3 id="如果-shouldComponentUpdate-返回-false，如何强制组件更新？"><a href="#如果-shouldComponentUpdate-返回-false，如何强制组件更新？" class="headerlink" title="如果 shouldComponentUpdate 返回 false，如何强制组件更新？"></a>如果 <strong>shouldComponentUpdate</strong> 返回 false，如何强制组件更新？</h3><p>听到这个问题，也是一脸问号，什么操作？仔细想了下可能考验 React 相关 API？<br>如果要实现这种效果可以用<code>forceUpdate</code>方法，其会跳过<code>shouldComponentUpdate</code>直接去更新组件，使用也很简单，在父组件通过 ref 获取到子组件，然后直接调用这个方法即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//? 父组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">loader</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    <span class="built_in">this</span>.child = React.createRef();</span><br><span class="line">    <span class="built_in">this</span>.reRender= <span class="built_in">this</span>.reRender.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">reRender</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//! 强行更新，慎用</span></span><br><span class="line">    <span class="built_in">this</span>.child.current.forceUpdate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.reRender</span> &#125;&gt;</span>重新渲染<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Children</span> <span class="attr">ref</span>=<span class="string">&#123;this.child&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//? 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;shouldComponentUpdate false 老子照样重新渲染！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JS-如何并发执行多个异步请求？"><a href="#JS-如何并发执行多个异步请求？" class="headerlink" title="JS 如何并发执行多个异步请求？"></a>JS 如何并发执行多个异步请求？</h3><p>听到这个问题，我还以为听错了，异步请求本来不都是并发的吗？最后确认可能是需要全部执行完成后，在执行回调逻辑，这就非常简单了，根据需求选择 Promsie 中的 <code>all</code>或者<code>race</code>即可。</p><h3 id="箭头函数需要注意的点"><a href="#箭头函数需要注意的点" class="headerlink" title="箭头函数需要注意的点"></a>箭头函数需要注意的点</h3><p>没什么技术含量的问题，箭头函数中最需要注意的便是<code>this</code>的指向问题了，JavaScript 其它函数都根据怎么调用获取 this 的，但是<strong>箭头函数没有 this，它只会从自己的作用域链的上一层继承this</strong>。</p><h3 id="如何规范代码"><a href="#如何规范代码" class="headerlink" title="如何规范代码"></a>如何规范代码</h3><ol><li>eslint 指定一份代码规范，便于统一代码格式。</li><li>开启严格模式，React 在根目录使用<code>&lt;React.StrictMode&gt;</code>包裹，Vuex <code>strict</code>配置打开，Mobx <code>useStrict</code> 加上等等。</li><li>多检查代码，碰到不合理的代码尽量修改，多多利用编译器插件，对这部分有大用，例如在没做完或还需要处理的逻辑上加上<code>//TODO</code>。</li><li>代码多写注释。</li></ol><h3 id="生产和开发环境变量如何设置？"><a href="#生产和开发环境变量如何设置？" class="headerlink" title="生产和开发环境变量如何设置？"></a>生产和开发环境变量如何设置？</h3><p>如果项目是使用 create-react-app 创建的，那么内部自动包含了 <strong>process.env.NODE_ENV</strong> 变量。我们可以使用其创建其他变量。<br>或者引入<code>react-scripts</code>依赖，根目录下新建<code>.env</code>或者生产开发环境下的文件，内部文件使用<code>process.env</code>访问即可。</p><h3 id="webpack-常用配置"><a href="#webpack-常用配置" class="headerlink" title="webpack 常用配置"></a>webpack 常用配置</h3><p>随便说了几个简单配置，还是很简单的：</p><ul><li><strong>mode：</strong>打包模式。</li><li><strong>entry：</strong>项目入口文件，可以单入口文件，也可以多入口。</li><li><strong>output：</strong>项目输出文件，也就是打包之后的文件地址。</li><li><strong>module：</strong>根据不同的文件，选择不同的代码解析工具。</li><li><strong>plugins：</strong>webpack 打包时的插件。</li><li><strong>devtool：</strong>调试代码的方式比如常用的 sourcemap。</li></ul><h3 id="说出几个-HTTP-缓存的属性"><a href="#说出几个-HTTP-缓存的属性" class="headerlink" title="说出几个 HTTP 缓存的属性"></a>说出几个 HTTP 缓存的属性</h3><p>一张图：</p><p><img data-src="https://img.bipch.cn/2021/03/29/066c8df413940.png" alt=""></p><p>厚颜无耻的链接下本人<a href="/http-cache">文章</a>。</p><h3 id="说下网站部署后的安全问题"><a href="#说下网站部署后的安全问题" class="headerlink" title="说下网站部署后的安全问题"></a>说下网站部署后的安全问题</h3><p>捡了两个简单的说<a href="/xss"><code>XSS</code>(跨域脚本攻击)</a>、<a href="/csrf"><code>CSRF</code>(跨站请求伪造)</a>，至于怎么攻击、怎么防范，网上一抓一大把相似文章，这里就厚颜无耻的链了我的两篇文章。</p><h2 id="2021-03-30"><a href="#2021-03-30" class="headerlink" title="2021-03-30"></a>2021-03-30</h2><p>这次公司都是 Vue 项目，但是太长时间没有看 Vue 相关知识了，所以发挥较差。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>没什么好说的，三个阶段挂载、更新、卸载阶段。详细没有什么说的。</p><h3 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h3><p>组件之间传值方式有很多种：</p><ol><li>父组件通过<code>props</code>将值传到子组件中，子组件通过<code>$emit</code>调用父组件方法修改。</li><li>借助<code>Vuex</code>，比较好用 Vue 中的数据流管理插件，如果组件嵌套过多比较推荐。</li><li>借助<code>$emit</code>触发事件，在公用父组件使用 <code>$on</code>监听(<strong>极度不推荐，维护大问题</strong>)。</li></ol><h3 id="简单说下-Vue-实现基本原理"><a href="#简单说下-Vue-实现基本原理" class="headerlink" title="简单说下 Vue 实现基本原理"></a>简单说下 Vue 实现基本原理</h3><p>最重要的便是<strong>双向绑定</strong>，而在 Vue 3.0 之前主要依靠<code>Object.defineProperty()</code>方法，而 3.0 之后便修改为了<code>ES6 Proxy</code>。</p><p>所有<code>data</code>中的数据都会使用<code>defineProperty</code>拦截(不能拦截整个对象，只能一个个属性拦截)，拦截之后每当界面读取<code>data</code>中的数据时，自动调用拦截中的 <strong>get</strong> 逻辑，而一旦<code>data</code>数据改变会立即调用相应的 <strong>set</strong> 逻辑，监听到数据的改变后通知所有该数据的订阅者更新，重新render 该组件（子组件不会重新渲染），生成新的虚拟 DOM 树，并对比新虚拟 DOM 树和旧虚拟 DOM 树中每个节点的差别，最后合并为一个最终的渲染 DOM 树渲染到界面上。</p><h3 id="Vuex简单的实现原理"><a href="#Vuex简单的实现原理" class="headerlink" title="Vuex简单的实现原理"></a>Vuex简单的实现原理</h3><p>因为只是简单介绍，所以就简单说下就好，Vuex 中的 <code>state</code> 借助 Vue 中的 data 进行响应式，我们可以将其看作 data，而 <code>getters</code> 也是借助 Vue 的 computed 进行实时监听，并且引入<code>Mutation</code>和<code>Action</code>来修改状态，并引入<code>Module</code>来分割代码块。</p><p>Vuex 创建完成后，如果在其子组件中调用<code>this.$store</code>或者其提供的任何提供的<code>mapState、mapGetters、 mapActions、 mapMutations</code>辅助函数，都会借助 Vux 中的 mixin 机制，并混合 <strong>beforeCreate</strong> 钩子将 <code>store</code> 注入至 vue 组件实例上，并注册了 vuex store 的引用属性 <code>$store</code>！</p><h3 id="amp-36route-和-amp-36touter-区别"><a href="#amp-36route-和-amp-36touter-区别" class="headerlink" title="&amp;#36route 和 &amp;#36touter 区别"></a>&amp;#36route 和 &amp;#36touter 区别</h3><ul><li><strong>&amp;#36touter：</strong>该属性是 VueRouter 的一个全局实例对象，主要包含了 VueRouter 提供的属性和方法(如<strong>push</strong>、<strong>replace</strong>、<strong>go</strong>)。</li><li><strong>&amp;#36route：</strong>该属性表示当前路由的信息，包括当前界面路径、参数、属性、名称….主要用于接收传入的参数。</li></ul><h3 id="路由导航守卫有几种？"><a href="#路由导航守卫有几种？" class="headerlink" title="路由导航守卫有几种？"></a>路由导航守卫有几种？</h3><p><strong>3</strong> 种，总计有 <strong>7</strong> 个：</p><ul><li><strong>全局导航钩子：</strong><code>beforeEach</code>、<code>beforeResolve</code>、<code>afterEach</code>；</li><li><strong>单独路由独享组件：</strong><code>beforeEnter</code>；</li><li><strong>组件内的钩子：</strong><code>beforeRouteEnter</code>、<code>beforeRouteUpdate</code>、<code>beforeRouteLeave</code>；</li></ul><h3 id="传参有几种方式"><a href="#传参有几种方式" class="headerlink" title="传参有几种方式"></a>传参有几种方式</h3><p>说实话不知道这题是干什么的。除了 <strong>params</strong> 和 <strong>query</strong> 还有别的？<br>后面他又问了句，刷新界面 <strong>params</strong> 会消失吗？这也是莫名其妙，这种方式传参是将参数传入到 vue-router 中，你说刷新界面消失不消失，就离谱。<br>不知道是干什么的。</p><h3 id="sass-如何定义变量和函数"><a href="#sass-如何定义变量和函数" class="headerlink" title="sass 如何定义变量和函数"></a>sass 如何定义变量和函数</h3><ol><li><strong>变量：</strong> sass 定义变量使用<code>$</code>；</li><li><strong>函数：</strong> 函数主要依靠<code>@function</code>和<code>@return</code>，前者创建函数，后者表明了函数将返回的值。内置了很多常用的方法例如：<ul><li><strong>percentage：</strong>数字转百分比；</li><li><strong>round：</strong>将一个数四舍五入为一个最接近的整数。</li><li><strong>ceil：</strong>返回最接近的整数，向上取整。</li><li><strong>floor：</strong>返回最接近的整数，向下取整。</li></ul></li></ol><h3 id="sass如何解析"><a href="#sass如何解析" class="headerlink" title="sass如何解析"></a>sass如何解析</h3><p>不知道具体想表达什么？webpack 配置？<br>需要在<code>module</code>属性中<code>loaders</code>配置以 scss 解为文件的解析方式，例如使用<code>sass-loader</code>解析，当然 sass 也需要实现下载完成。<br>不知道想表达什么。</p><h3 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h3><p>由于并没有进行过移动端的开发，所以回答了 H5 的移动端，那就主要依靠 <strong>rem + @media</strong>。<br>而如果这样回答，那么 rpx 的计算方式是不可避免的。当然也很简单，因为 rem 计算依靠根元素的字体大小，根据根元素字体大小进行计算即可。</p><h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><p>简单来说防抖就是每次执行逻辑前，先使用<code>setTimeout</code>进行短时间的缓冲，当这段时间内该逻辑再次触发，便清除上一次缓冲内容，开启新的缓冲。<br>而节流则是定义布尔类型变量，使用布尔类型变量判断上次是否执行完成，只有上次执行完成，才能开启下次的请求。<br>厚颜无耻的<a href="/antiShake-throttle">贴篇文章</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一些有趣平时又不轻易能刷到的一些问题，会持续进行更新。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://bipch.cn/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://bipch.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>虚拟DOM</title>
    <link href="https://bipch.cn/virtual-dom/"/>
    <id>https://bipch.cn/virtual-dom/</id>
    <published>2021-03-23T12:03:49.000Z</published>
    <updated>2021-11-09T08:50:36.598Z</updated>
    
    <content type="html"><![CDATA[<p>如今的前端开发越来越丰富，所用的框架也越来越多，从以前的 React 到后面的 angularJS、Vue等，但无论是那个框架其内部都采取了虚拟DOM、以及 DOM-diff 算法来提升项目运行速度，那么虚拟DOM是个什么东西呢？ DOM-diff 是怎么实现的呢？为什么大多数框架都选择使用它们呢？</p><span id="more"></span><h2 id="神奇的虚拟DOM"><a href="#神奇的虚拟DOM" class="headerlink" title="神奇的虚拟DOM"></a>神奇的虚拟DOM</h2><p>虚拟DOM并不是什么新鲜得定义，简单说便是使用 JS 去按照 DOM结构 来实现的树形结构对象。</p><h3 id="创建虚拟DOM"><a href="#创建虚拟DOM" class="headerlink" title="创建虚拟DOM"></a>创建虚拟DOM</h3><p>我们可以借鉴下 React 中的 <a href="https://reactjs.bootcss.com/docs/jsx-in-depth.html">React.createElement</a> 方法创建虚拟DOM。<br>该方法主要接收 3 个参数：</p><ol><li>参数一：表示当前元素的名称。</li><li>参数二：表示当前元素的属性。</li><li>参数三：表示当前元素的子节点，多个可以用数组的新式传入。</li></ol><p>方法最终返回一个虚拟DOM。<br>既然是这种形式，我们模仿其数据封装即可，我们创建一个工具类，方便扩展和使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚拟DOM元素的类，用来描述DOM</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">type, props, children</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type;</span><br><span class="line">    <span class="built_in">this</span>.props = props;</span><br><span class="line">    <span class="built_in">this</span>.children = children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建虚拟DOM，返回虚拟节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Element(type, props, children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就进行了一个简单的封装，我们在界面上添加下面内容进行测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> virtualDom = createElement(<span class="string">&#x27;ul&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;list&#x27;</span>&#125;, [</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, <span class="string">&#x27;尼罗河上的惨案&#x27;</span>),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, <span class="string">&#x27;东方快车谋杀案&#x27;</span>),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, <span class="string">&#x27;无人生还&#x27;</span>)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(virtualDom);</span><br></pre></td></tr></table></figure><p>运行之后，最终控制台输出下面的内容：</p><p><img data-src="https://img.bplink66.com/2021/11/09/x758ed1n5l.png" alt=""></p><p>这就很符合我们需求了，但其只是对需要渲染节点的描述，界面上是无法查看到的。</p><h3 id="渲染自定义DOM"><a href="#渲染自定义DOM" class="headerlink" title="渲染自定义DOM"></a>渲染自定义DOM</h3><p>虚拟DOM创建完成后，浏览器并不能识别，我们需要将其转化为浏览器能识别的真实DOM，并通过 <code>appendChild</code> 方法将其插入到界面中。<br>那么我们封装一个 render 方法用于将虚拟DOM转换为真实DOM：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render 将 我们定义的虚拟DOM 转化成真实DOM</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">domObj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建对应的元素</span></span><br><span class="line">  <span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(domObj.type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历所有的属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> domObj.props) &#123;</span><br><span class="line">    <span class="comment">// 设置 DOM 属性</span></span><br><span class="line">    setAttr(el, key, domObj.props[key]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历子节点</span></span><br><span class="line">  <span class="comment">// 判断子节点是多个还是一个</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(domObj.children))&#123;</span><br><span class="line">    domObj.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">      el.appendChild(createDom(child));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    el.appendChild(createDom(domObj.children));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> el;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果节点类型是自定义 虚拟DOM 继续递归，否则为 文字 直接创建</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDom</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((node <span class="keyword">instanceof</span> Element) ? render(node) : <span class="built_in">document</span>.createTextNode(node))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 DOM 属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setAttr</span>(<span class="params">node, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;value&#x27;</span>:</span><br><span class="line">      <span class="comment">// node 是一个 input 或者 textarea 就直接设置其 value</span></span><br><span class="line">      <span class="keyword">if</span> (node.tagName.toLowerCase() === <span class="string">&#x27;input&#x27;</span> ||</span><br><span class="line">        node.tagName.toLowerCase() === <span class="string">&#x27;textarea&#x27;</span>) &#123;</span><br><span class="line">        node.value = value;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.setAttribute(key, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;style&#x27;</span>:</span><br><span class="line">      <span class="comment">// 直接赋值行内样式</span></span><br><span class="line">      node.style.cssText = value;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      node.setAttribute(key, value);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素插入到页面内</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderDom</span>(<span class="params">el, target</span>) </span>&#123;</span><br><span class="line">  target.appendChild(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的 render 方法便完成了，其能把我们自定义的虚拟DOM结构，转化为浏览器能识别的真实DOM，我们修改测试代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> virtualDom = createElement(<span class="string">&#x27;ul&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;list&#x27;</span>&#125;, [</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, <span class="string">&#x27;尼罗河上的惨案&#x27;</span>),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, <span class="string">&#x27;东方快车谋杀案&#x27;</span>),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, <span class="string">&#x27;无人生还&#x27;</span>)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> el = render(virtualDom);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>).appendChild(el);</span><br></pre></td></tr></table></figure><p>这样直接通过 render 将虚拟DOM进行转换，转换成功后，使用刚才定义的 appendChild 方法插入到指定的节点上。最后得出下面的结果：</p><p><img data-src="https://img.bplink66.com/2021/11/09/2luolbzbc00.png" alt=""></p><p>结构完全能被浏览器识别，并可以正常渲染到界面上，这样我们便自定义了一个虚拟DOM的结构，并使用 render 方法进行转换，最后成功展示到浏览器上。<br>这个时候基础功能已经完成，下面就要关键的 DOM-diff 隆重登场了。</p><h2 id="DOM-diff登场"><a href="#DOM-diff登场" class="headerlink" title="DOM-diff登场"></a>DOM-diff登场</h2><p>Dom Diff 作用是，对比两棵任意树，并采用 <strong>先序深度优先遍历</strong> 的算法找到最少的转换步骤。<br>我们可以使用 Dom Diff 对比两个 虚拟DOM 的区别，并产出差异补丁对象，然后我们根据这个补丁来更新DOM（这里就将之前的虚拟DOM称之为(oldNode)，新的DOM称之为(newNode)）;<br>既然已经明白其作用了，那么我们开始一点点的实现：</p><ul><li>每个元素都该有一个补丁，需要定义一个补丁数组。</li><li>进行比对时，如果没有 new 节点，可以添加一个 <code>REMOVE</code> 补丁，表示不要替换：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!newNode) &#123;</span><br><span class="line">  current.push(&#123; <span class="attr">type</span>: <span class="string">&#x27;REMOVE&#x27;</span>, index &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 oldNode 和 newNode 节点都是文本，那就判断文本是否相同，不一致添加一个 <code>TEXT</code> 补丁：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isString(oldNode) &amp;&amp; isString(newNode)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (oldNode !== newNode) &#123;</span><br><span class="line">    current.push(&#123; <span class="attr">type</span>: <span class="string">&#x27;TEXT&#x27;</span>, <span class="attr">text</span>: newNode &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 oldNode 和 newNode 节点名称相同，那么我们需要判断它们的属性或者子节点是否相同：<ul><li>属性对比，如果不相同，我们添加 <code>ATTR</code> 补丁，并将 newAttr 的属性值传入。</li><li>子元素对比，递归对比 oldNode 和 newNode 的子元素。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldNode.type === newNode.type) &#123;</span><br><span class="line">  <span class="comment">// 属性对比</span></span><br><span class="line">  <span class="keyword">let</span> attr = diffAttr(oldNode.props, newNode.props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(attr).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    current.push(&#123; <span class="attr">type</span>: <span class="string">&#x27;ATTR&#x27;</span>, attr &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 如果有子节点，递归子节点</span></span><br><span class="line">  diffChildren(oldNode.children, newNode.children, patches);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果上面三种情况都没有发生，那就表示节点完全被替换了，我们添加一个 <code>REPLACE</code> 补丁，直接用 newNode 进行替换：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current.push(&#123; <span class="attr">type</span>: <span class="string">&#x27;REPLACE&#x27;</span>, newNode&#125;);</span><br></pre></td></tr></table></figure><ul><li>判断完毕之后，将所有的补丁进行整合放到大补丁中。</li></ul><p>最后我们结合上面的代码，得出下面的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOM 元素比对</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">oldTree, newTree</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 补丁对象</span></span><br><span class="line">  <span class="keyword">let</span> patches = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 树的索引</span></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 递归，对比各个DOM节点，得出补丁</span></span><br><span class="line">  walk(oldTree, newTree, index, patches);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> patches;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对比节点是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">oldNode, newNode, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 每个元素都有一个补丁</span></span><br><span class="line">  <span class="keyword">let</span> current = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!newNode) &#123;</span><br><span class="line">    <span class="comment">// 没有新元素，不替换</span></span><br><span class="line">    current.push(&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;REMOVE&#x27;</span>,</span><br><span class="line">      index</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isString(oldNode) &amp;&amp; isString(newNode)) &#123;</span><br><span class="line">    <span class="comment">// 都是字符串，判断是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (oldNode !== newNode) &#123;</span><br><span class="line">      current.push(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;TEXT&#x27;</span>,</span><br><span class="line">        <span class="attr">text</span>: newNode</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldNode.type === newNode.type) &#123;</span><br><span class="line">    <span class="comment">// 节点名称相同，对比属性是否相同</span></span><br><span class="line">    <span class="keyword">let</span> attr = diffAttr(oldNode.props, newNode.props);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(attr).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      current.push(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;ATTR&#x27;</span>,</span><br><span class="line">        attr</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有子节点，遍历子节点</span></span><br><span class="line">    diffChildren(oldNode.children, newNode.children, patches);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 说明节点已经被替换了</span></span><br><span class="line">    current.push(&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;REPLACE&#x27;</span>,</span><br><span class="line">      newNode</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前元素确实有补丁存在</span></span><br><span class="line">  <span class="keyword">if</span> (current.length) &#123;</span><br><span class="line">    <span class="comment">// 将元素和补丁对应起来，放到大补丁包中</span></span><br><span class="line">    patches[index] = current;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对比新老属性是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffAttr</span>(<span class="params">oldAttrs, newAttrs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> patch = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 对比新老属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> oldAttrs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldAttrs[key] !== newAttrs[key]) &#123;</span><br><span class="line">      patch[key] = newAttrs[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> newAttrs) &#123;</span><br><span class="line">    <span class="comment">// 老节点没有新节点的属性</span></span><br><span class="line">    <span class="keyword">if</span> (!oldAttrs.hasOwnProperty(key)) &#123;</span><br><span class="line">      patch[key] = newAttrs[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> patch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">oldChildren, newChildren, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(oldChildren))&#123;</span><br><span class="line">    oldChildren.forEach(<span class="function">(<span class="params">child, index</span>) =&gt;</span> &#123;</span><br><span class="line">      walk(child, newChildren[index], ++num, patches);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    walk(oldChildren, newChildren, ++num, patches);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码虽然又臭又长，可以对比上面的各个需求进行一点点分析，没太明白的话没关系，再反复看几遍试试，意外总是不期而遇的。</p><h2 id="补丁更新"><a href="#补丁更新" class="headerlink" title="补丁更新"></a>补丁更新</h2><p>上面已经通过 diff 方法计算到了补丁，下面需要通过补丁进行 DOM元素 的更新。<br>如果实现更新函数，其要接收两个参数，一个是要打补丁的元素，另一个就是所要打的补丁了，那么直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> allPatches;</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// 默认哪个需要打补丁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">node, patches</span>) </span>&#123;</span><br><span class="line">  allPatches = patches;</span><br><span class="line">  walk(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> current = allPatches[index++];</span><br><span class="line">  <span class="keyword">let</span> childNodes = node.childNodes;</span><br><span class="line">  childNodes.forEach(<span class="function"><span class="params">child</span> =&gt;</span> walk(child));</span><br><span class="line">  <span class="keyword">if</span> (current) &#123;</span><br><span class="line">    doPatch(node, current);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doPatch</span>(<span class="params">node, patches</span>) </span>&#123;</span><br><span class="line">  patches.forEach(<span class="function"><span class="params">patch</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (patch.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;ATTR&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> patch.attr) &#123;</span><br><span class="line">          <span class="keyword">let</span> value = patch.attr[key];</span><br><span class="line">          <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            setAttr(node, key, value);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.removeAttribute(key);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;TEXT&#x27;</span>:</span><br><span class="line">        node.textContent = patch.text;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;REPLACE&#x27;</span>:</span><br><span class="line">        <span class="keyword">let</span> newNode = patch.newNode;</span><br><span class="line">        newNode = (newNode <span class="keyword">instanceof</span> Element) ? render(newNode) : <span class="built_in">document</span>.createTextNode(newNode);</span><br><span class="line">        node.parentNode.replaceChild(newNode, node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;REMOVE&#x27;</span>:</span><br><span class="line">        node.parentNode.removeChild(node);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能根据我们的补丁，更新相关的 DOM 元素，下面分析下其怎么使用补丁进行更新的：</p><ul><li>由于多处都要使用补丁，这里先把补丁修改为全局数据。</li><li>使用先序深度优先遍历所有子节点，判断 DOM元素 是否需要补丁更新。</li><li>doPatch 打补丁方法会根据传递的 patches 进行遍历，然后根据补丁的类型执行不同的操作。<ul><li>ATTR: 表示设置 DOM 的属性，直接设置属性 setAttr; 如果不具有这个属性，直接删除这个属性。</li><li>TEXT: 文字的补丁，直接替换文本的内容。</li><li>REPLACE: 直接使用新节点去替换老节点，需要判断新节点是不是 Element 类型，不是表示文本节点。</li><li>REMOVE: 删除该节点。</li></ul></li><li>将我们方法导出即可。</li></ul><h2 id="结合"><a href="#结合" class="headerlink" title="结合"></a>结合</h2><p>上面代码已经实现了 DOM 和 DOM-diff 方法，我们把其整合起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> virtualDom = createElement(<span class="string">&#x27;ul&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;list&#x27;</span>&#125;, [</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, <span class="string">&#x27;尼罗河上的惨案&#x27;</span>),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, <span class="string">&#x27;东方快车谋杀案&#x27;</span>),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, <span class="string">&#x27;无人生还&#x27;</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 虚拟 dom 转能被浏览器识别的 dom</span></span><br><span class="line"><span class="keyword">let</span> el = render(virtualDom);</span><br><span class="line"><span class="comment">// 渲染</span></span><br><span class="line">renderDom(el, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> virtualDom2 = createElement(<span class="string">&#x27;ul&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;list&#x27;</span>&#125;, [</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, <span class="string">&#x27;阿加莎克里斯蒂&#x27;</span>),</span><br><span class="line">  createElement(<span class="string">&#x27;li&#x27;</span>, &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, <span class="string">&#x27;柯南道尔&#x27;</span>)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> patches = diff(virtualDom, virtualDom2);</span><br><span class="line"><span class="built_in">console</span>.log(patches);</span><br><span class="line"></span><br><span class="line">patch(el, patches);</span><br></pre></td></tr></table></figure><p>最后界面成功替换，补丁打印出下面的内容：</p><p><img data-src="https://img.bplink66.com/2021/11/09/gr6gzpxo45.png" alt=""></p><h2 id="四句话"><a href="#四句话" class="headerlink" title="四句话"></a>四句话</h2><p>我们可以梳理下DOM-diff的过程：</p><ol><li>使用JS对比描述DOM(虚拟DOM)。</li><li>将虚拟DOM转换为真实DOM并插入界面中(render)。</li><li>如果有事件修改了虚拟DOM，通过 DOM-diff 比较两棵虚拟DOM树的差异，得到差异补丁。</li><li>最后通过补丁，更新真正的DOM。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6844903806132568072">让虚拟DOM和DOM-diff不再成为你的绊脚石</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;如今的前端开发越来越丰富，所用的框架也越来越多，从以前的 React 到后面的 angularJS、Vue等，但无论是那个框架其内部都采取了虚拟DOM、以及 DOM-diff 算法来提升项目运行速度，那么虚拟DOM是个什么东西呢？ DOM-diff 是怎么实现的呢？为什么大多数框架都选择使用它们呢？&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://bipch.cn/categories/JavaScript/"/>
    
    
    <category term="Virtual DOM" scheme="https://bipch.cn/tags/Virtual-DOM/"/>
    
  </entry>
  
  <entry>
    <title>CSRF</title>
    <link href="https://bipch.cn/csrf/"/>
    <id>https://bipch.cn/csrf/</id>
    <published>2021-03-21T04:23:00.000Z</published>
    <updated>2021-11-09T09:35:13.169Z</updated>
    
    <content type="html"><![CDATA[<p>CSRF 全称为 Cross-site request forgery 也可以称之为 <strong>跨站请求伪造</strong>，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法，换一句话说就是攻击者盗用了你的身份，以你的名义发送恶意请求。</p><span id="more"></span><h2 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h2><p>造成该问题的原因是服务端只能简单的验证用户的身份，却不能保证请求本身是用户自愿发出的。</p><p>换句话说就是有人恶意在网站插入了一段具有攻击性代码，当其他用户访问时，恶意代码便会执行，从而窃取到一些用户私密的数据，或者发送一些用户不知道的请求。</p><p>比如有个银行的接口为 <code>xxx.com/money/transfer?user=87345553ert&amp;money=200</code> 参数中 <strong>user</strong> 表示转账的账户，而 <strong>money</strong> 表示转折的金额，例如我们登陆了一个大型系统，登陆后 token 进行了存储，如果我们此时没有退出并且访问了项目的恶意的链接，链接里的界面访问了 <code>xxx.com/money/transfer?user=87345553ert&amp;money=200</code> 接口，这样可怜的受害者便莫名其妙的转给 <strong>87345553ert</strong> 了 200。</p><p>当然这只是简单的举例，因为凡是设计到这类敏感接口，都在需要 key、验证码、登录密码和支付密码等一系列屏障。</p><h2 id="CSRF的防御"><a href="#CSRF的防御" class="headerlink" title="CSRF的防御"></a>CSRF的防御</h2><p>既然 CSRF 危害那么大，那么可以使用什么方式进行防御呢？</p><h3 id="将-cookie-设置为-HttpOnly"><a href="#将-cookie-设置为-HttpOnly" class="headerlink" title="将 cookie 设置为 HttpOnly"></a>将 cookie 设置为 HttpOnly</h3><p>有可能会有一部分恶意网址使用 <code>XSS漏洞</code> 盗取用户浏览器 cookie 数据，获取到 cookie 数据便可很简单的在任意地方进行 CSRF 形式的漏洞攻击了，那么就需要我们防止 <code>XSS</code> 漏洞获取关键数据，所以此时便需要 <code>HttpOnly</code> 属性将敏感 token 设置为禁止操作的。<br>例如使用 koa2 框架当用户登陆成后，在后台可以添加下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ctx.cookies.set(</span><br><span class="line">  <span class="string">&#x27;token&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;8sd95vd9f8dc5d8f78d5c28d.8dc8d2f8d7f48d7fdf.dsf47s4d8s&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// cookie有效时长</span></span><br><span class="line">    <span class="attr">maxAge</span>: <span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">    <span class="comment">// cookie可用域名</span></span><br><span class="line">    <span class="attr">domain</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    <span class="comment">// 默认false，设置成true表示只有https可以访问</span></span><br><span class="line">    <span class="attr">secure</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// true，客户端不可读取</span></span><br><span class="line">    <span class="attr">httpOnly</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否覆盖</span></span><br><span class="line">    <span class="attr">overwrite</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>服务端返回的 response 中都会包含一个 <code>set-cookie</code> 字段，用于描述 Cookie，浏览器接收到 <code>response.set-cookie</code> 字段之后会根据描述自动添加 cookie：</p><p><img data-src="https://img.bplink66.com/2021/11/05/19weu2b672y.png" alt=""></p><p>这样便通过后台给关键字段设置了 <code>HttpOnly</code> 属性，设置成功后该 cookie 便不能被 JS 操作，保证了 cookie 中的数据安全性。</p><h3 id="增加-token-验证"><a href="#增加-token-验证" class="headerlink" title="增加 token 验证"></a>增加 token 验证</h3><p>CSRF 只是攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于 cookie 中，所以攻击者可以在不知道用户 cookie 的方式下进行攻击。那么我们可以得出另外一个 CSRF 的防御方式：<strong>在请求中添加另一个无法伪造的字段，并且这个字段不能存在与 cookie 中</strong>。介于此我们可以在提交敏感表单时，添加一个随机的 token，并在服务端进行 token 校验，若失败则认为 CSRF 攻击，从而拒绝该请求。<br>比如在进入到敏感界面时，后台生成一个 token 并返回，前端接收赋值给一个变量，执行转账接口时，将这个 token 变量添加进请求数据中，后台接收后进行比对，比对失败就认为是 CSRF 漏洞攻击。<br>这样也能屏蔽掉一些 CSRF 攻击。</p><h3 id="验证-HTTP-Referer"><a href="#验证-HTTP-Referer" class="headerlink" title="验证 HTTP Referer"></a>验证 HTTP Referer</h3><p>虽然 HTTP 是无状态协议，但其会将当前界面地址传入到后台中，我们可以在<code>referer</code>属性获取，只有访问到指定界面，我们才会允许访问，不然拒绝掉此次请求，但是这种方式非常的不灵活，因为后台接口是会提供给多个项目，包括pc端、移动端、微信小程序等调用，所以其路径也基本不会固定，单是如果需要这种效果也还是可以进行 CSRF 拦截的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(ctx.request.headers[<span class="string">&#x27;referer&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CSRF 攻击是利用被攻击者登陆之后的 token，进行一些恶意的操作，因为后台服务无法判断当前请求是不是用户希望的操作，为了解决这一漏洞我们也可以从多个方面进行拦截，上面只是一些较为常用的方法，当然现在这些敏感的数据一般都需要短信验证，支付宝验证、手机令牌等多种验证方式上面只是较为基础和常用的拦截方式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSRF 全称为 Cross-site request forgery 也可以称之为 &lt;strong&gt;跨站请求伪造&lt;/strong&gt;，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法，换一句话说就是攻击者盗用了你的身份，以你的名义发送恶意请求。&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞攻击" scheme="https://bipch.cn/categories/%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/"/>
    
    
    <category term="跨站请求伪造" scheme="https://bipch.cn/tags/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>Session和Cookie</title>
    <link href="https://bipch.cn/session-cookie/"/>
    <id>https://bipch.cn/session-cookie/</id>
    <published>2021-03-18T10:23:21.000Z</published>
    <updated>2021-11-09T11:55:38.944Z</updated>
    
    <content type="html"><![CDATA[<p>由于 http 是一种无状态的协议，所以服务端为了区分每次进行会话的用户，就需要用某种机制来识具体的用户，这个机制就是 Session。</p><span id="more"></span><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session 是个非常抽象概念，开发者为了将一个个分离的 http 请求关联起来，便于服务端分析和记录，进而衍生出 Session 的概念。<br>而为了区分每个用户 Session 的技术，便称之为 Session实现。比如：</p><ul><li>Cookie 中存储一个 Session ID 字段，服务器端保存会话信息，当服务端接收到请求后，根据前端传递的值在服务端查询回话相关信息，如果没有重新创建，这是 Tomcat 的实现方法。</li><li>将关键信息通过指定算法加密，将加密后的数据都保存到 Cookie 中，每次请求来了，直接从 Cookie 里提取数据，并根据防伪签名解密，这是 JWT 的实现方法。</li><li>在 Cookie 中存放个 token(唯一标识)，状态不存在中间件里，而是存在 Redis 里，这也是一种 Session 实现方法。</li></ul><p>上面这样技术都可以称之为 Session实现，所以请 <strong>一定不要混淆 <code>session</code> 和 <code>session实现</code></strong>。<br>我看到过一个很恰当的比喻：<strong>只要人们还出行，交通工具就不可缺失，只是实现的方法从走路，变成了马车，在变成汽车、火车、飞机等，将来还可能火箭等。</strong><br>session 就像 “交通工具” 工具，其只是一个概念，没有什么特定的形式，而 session实现 可以是走路、汽车、火车等。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>与 Session 这种抽象的概念对应的便是 Cookie，Cookie 是一个实际存在的数据，保存在浏览器内存中，每次 http 协议浏览器都会自动拼接到 header 字段中，我们可以将其理解为 Session 的一种实现方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以结合上面的概念所以 cookie 和 session，你可以认为是同一层次的概念，也可以认为是不同层次的概念。在具体实现中 session 因为 session id 的存在，通常要借助 cookie 实现，但这并非必要，只能说是通用性较好的一种实现方案。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于 http 是一种无状态的协议，所以服务端为了区分每次进行会话的用户，就需要用某种机制来识具体的用户，这个机制就是 Session。&lt;/p&gt;</summary>
    
    
    
    <category term="HTTP" scheme="https://bipch.cn/categories/HTTP/"/>
    
    
    <category term="Cookie" scheme="https://bipch.cn/tags/Cookie/"/>
    
    <category term="Session" scheme="https://bipch.cn/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript原型链</title>
    <link href="https://bipch.cn/prototype-chain/"/>
    <id>https://bipch.cn/prototype-chain/</id>
    <published>2021-03-11T08:19:23.000Z</published>
    <updated>2021-11-09T14:34:50.971Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 中数据类型基本分为基本类型与引用类型，基本类型包括 String、Number、Boolean、undefined、Null以及 ES6 中新提出的 Symbol，引用类型多为一些对象，比如 Object、Function 等，在 ES6 中又添加了一个新的引用对象 <strong>class</strong>，虽然使用方式与其它的语言十分的相似，但其内部还是通过 <code>Function</code> 实现，只是另外借助了<code>原型对象</code>、<code>原型链</code>两个概念。</p><span id="more"></span><h2 id="普通对象与函数对象"><a href="#普通对象与函数对象" class="headerlink" title="普通对象与函数对象"></a>普通对象与函数对象</h2><p>在 JavaScript 中的数对象都可以分为 <strong>普通对象</strong> 和 <strong>函数对象</strong>，通过 Function 实例的对象均为函数对象，反之则为普通对象，但是 Object 和 Function 为函数对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 =<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> f1();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;str&#x27;</span>,<span class="string">&#x27;console.log(str)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>); <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>); <span class="comment">//function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f1); <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f2); <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f3); <span class="comment">//function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o1); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o2); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o3); <span class="comment">//object</span></span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>每一个对象都内置一个 <code>constructor</code> 属性，该属性指向创建其的函数对象。例如我们有下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;world&#x27;</span>, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor === Person);</span><br></pre></td></tr></table></figure><p>所以我们便可以得出：<code>constructor 属性返回创建此对象的函数的引用</code>。</p><h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>JavaScript 中每一个 <strong>函数对象</strong> 都包含着一些预定义的属性，例如都内置一个 <code>prototype</code> 属性，其会返回一个对象，而这个对象便称之为 <code>原型对象</code>。<br>其实就是一个普通的 JS 对象，主要目的是保存着实例共享的方法，内置了两个属性：</p><ol><li><code>constructor</code>：始终指向创建当前对象的构造函数。</li><li><code>___proto___</code>：该属性指向构造函数的原型对象，所以这里指向 <code>Object.prototype</code>。</li></ol><p>比如下面代码执行结果为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Person.prototype.constructor</span> === Person  // <span class="literal">true</span></span><br><span class="line"><span class="attr">Person.prototype.constructor</span> === person1.constructor  // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong><em>proto</em></strong></h2><p>JavaScript 中任何的对象数据都会内置一个 <code>___proto___</code> 属性，其指向 <strong>构造函数的原型对象</strong>。<br>可能听着有些绕，但是明白了上面两个概念，其实很容易理解，例如上面代码中：<br><strong>person1</strong> 有个内置 <strong>proto</strong> 属性，而它的构造器返回 <strong>Person</strong> 对象，那么构造函数的原型对象是 <strong>Person.prototype</strong>，那么就可以写出：<code>person1.__proto__ === Person.prototype</code>。</p><p>其实到这一步以及可以发现以及应约见构建出一条链子出来了，而这条链，便是 <code>原型链</code>。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>上面以及介绍完原型链的定义了重要的定义，那么可以看下这些问题进行检测：</p><ol><li><strong>person1.<strong>proto</strong></strong> 等于什么？ <code>person1.__proto__ === Person.prototype</code>。</li><li><strong>Person.<strong>proto</strong></strong> 等于什么？ <code>Person.__proto__ === Function.prototype</code>。</li><li><strong>Person.prototype.<strong>proto</strong></strong> 等于什么？ <code>Person.prototype.__proto__ === Object.prototype</code>。</li><li><strong>Object.<strong>proto</strong></strong> 等于什么？ <code>Object.__proto__ === Function.prototype</code>。</li><li><strong>Object.prototype.<strong>proto</strong></strong> 等于什么？ <code>Object.prototype.__proto__ === null</code>。</li></ol><p>其实原型链就是一直深扒 <code>__proto__</code> 属性，一直到找到我们想要的或为 null。<br>例如我们需要 <code>person1</code> 中的 <code>toString</code> 方法，其回先找 <code>person1.__proto__</code> 也就是上面的 <code>Person.prototype</code> 发现其只有一个 <strong>sayName</strong> 没有我们找到，回继续探索 <code>Person.prototype.__proto__</code> 也就到了 <code>Object.prototype</code> 找到结束并返回，否则知道其为 null 为止。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实总结起来很简单：</p><ol><li>任何对象都拥有一个 <code>__proto__</code> 属性，该属性返回其构造函数的原型对象。</li><li>只有函数对象 <code>prototype</code> 属性，目的就是为了属性共享，其返回了一个该属性的原型对象。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;JavaScript 中数据类型基本分为基本类型与引用类型，基本类型包括 String、Number、Boolean、undefined、Null以及 ES6 中新提出的 Symbol，引用类型多为一些对象，比如 Object、Function 等，在 ES6 中又添加了一个新的引用对象 &lt;strong&gt;class&lt;/strong&gt;，虽然使用方式与其它的语言十分的相似，但其内部还是通过 &lt;code&gt;Function&lt;/code&gt; 实现，只是另外借助了&lt;code&gt;原型对象&lt;/code&gt;、&lt;code&gt;原型链&lt;/code&gt;两个概念。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://bipch.cn/categories/JavaScript/"/>
    
    
    <category term="原型链" scheme="https://bipch.cn/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Es6-Es12新特性</title>
    <link href="https://bipch.cn/es6-es12/"/>
    <id>https://bipch.cn/es6-es12/</id>
    <published>2021-03-10T10:44:41.000Z</published>
    <updated>2021-08-25T08:14:26.544Z</updated>
    
    <content type="html"><![CDATA[<p>自 2015 年推出 ES6 规则之后，每个一年几乎都会推出一些新增的特性，这些特性能为开发过程中提供许多的帮助，下面简单总结下自 Es6(2015) ~ Es12(2021) 推出的新特性，当然之后记录比较常用的，那些不常用的使用时再去查询也不迟。</p><span id="more"></span><h2 id="Es6"><a href="#Es6" class="headerlink" title="Es6"></a>Es6</h2><h3 id="1-类-class"><a href="#1-类-class" class="headerlink" title="1. 类(class)"></a>1. 类(class)</h3><p>这里一定要注意，JS 并没有 Class 的概念，就算是 Es6 新增的其本质任然是 Function + 原型链。<br>使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"> name </span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;My name&#x27;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;橙子&#x27;</span>);</span><br><span class="line">person.toString();</span><br></pre></td></tr></table></figure><h3 id="2-let-和-const"><a href="#2-let-和-const" class="headerlink" title="2. let 和 const"></a>2. let 和 const</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;橙子&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> list = [];</span><br></pre></td></tr></table></figure><h3 id="3-Arrow"><a href="#3-Arrow" class="headerlink" title="3. Arrow"></a>3. Arrow</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="4-Module"><a href="#4-Module" class="headerlink" title="4. Module"></a>4. Module</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sub(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><h3 id="5-模板字符串"><a href="#5-模板字符串" class="headerlink" title="5. 模板字符串"></a>5. 模板字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;橙子&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`Your name is <span class="subst">$&#123;name&#125;</span>`</span>;</span><br></pre></td></tr></table></figure><h3 id="6-解构赋值"><a href="#6-解构赋值" class="headerlink" title="6. 解构赋值"></a>6. 解构赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b] = [<span class="number">6</span>, <span class="number">9</span>];</span><br></pre></td></tr></table></figure><h3 id="7-参数默认值"><a href="#7-参数默认值" class="headerlink" title="7. 参数默认值"></a>7. 参数默认值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a = <span class="number">1</span>, b = <span class="number">2</span></span>) =&gt;</span> a + b;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">sum();</span><br></pre></td></tr></table></figure><h3 id="8-展开"><a href="#8-展开" class="headerlink" title="8. 展开"></a>8. 展开</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>]]);</span><br></pre></td></tr></table></figure><h3 id="9-数据简写"><a href="#9-数据简写" class="headerlink" title="9. 数据简写"></a>9. 数据简写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name=<span class="string">&#x27;橙子&#x27;</span>,</span><br><span class="line"><span class="keyword">const</span> obj = &#123; name &#125;;</span><br></pre></td></tr></table></figure><h3 id="10-Promise"><a href="#10-Promise" class="headerlink" title="10. Promise"></a>10. Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;橙子&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(result); &#125;);</span><br></pre></td></tr></table></figure><p>结果为 0、橙子，如果没有看出可以了解下微观和宏观任务。</p><h3 id="11-symbol"><a href="#11-symbol" class="headerlink" title="11. symbol"></a>11. symbol</h3><p>Es6 新增的基本数据类型，它和 <strong>let</strong> 和 <strong>const</strong> 不同，其为一种基本数据类型，也是除了 String、Number、Boolean、undefined、Null、还新增了 Symbol  用于表示独一无二的。<br>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">&quot;KK&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol(KK)</span></span><br><span class="line"><span class="built_in">console</span>.log(sy);</span><br><span class="line"><span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span>(sy);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 即使定义一样，也不可能相等</span></span><br><span class="line"><span class="keyword">let</span> sy1 = <span class="built_in">Symbol</span>(<span class="string">&quot;kk&quot;</span>); </span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">sy === sy1;</span><br></pre></td></tr></table></figure><h2 id="Es7"><a href="#Es7" class="headerlink" title="Es7"></a>Es7</h2><h3 id="1-Array-prototype-includes"><a href="#1-Array-prototype-includes" class="headerlink" title="1. Array.prototype.includes()"></a>1. Array.prototype.includes()</h3><p>判断字符串是否包含指定的子字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;I like oranges&quot;</span>;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> n = str.includes(<span class="string">&quot;oranges&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="2-指数运算"><a href="#2-指数运算" class="headerlink" title="2. 指数运算"></a>2. 指数运算</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="number">2</span>**<span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="Es8"><a href="#Es8" class="headerlink" title="Es8"></a>Es8</h2><h3 id="1-async-await"><a href="#1-async-await" class="headerlink" title="1. async/await"></a>1. async/await</h3><p>异步化编程的解决方案，最终返回的为 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">queryPage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// await 异步任务</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> queryPage();</span><br><span class="line">  <span class="comment">//<span class="doctag">TODO:</span> 逻辑处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Object-values"><a href="#2-Object-values" class="headerlink" title="2. Object.values()"></a>2. Object.values()</h3><p>返回给定对象自身的所有可枚举属性值的数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">love</span>: <span class="string">&#x27;orange&#x27;</span>, <span class="attr">user</span>: <span class="string">&#x27;I&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// [&#x27;orange&#x27;, &#x27;I&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj));</span><br></pre></td></tr></table></figure><h3 id="3-Object-entries"><a href="#3-Object-entries" class="headerlink" title="3. Object.entries()"></a>3. Object.entries()</h3><p>返回一个给定对象自身可枚举属性的键值对数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">love</span>: <span class="string">&#x27;orange&#x27;</span>, <span class="attr">user</span>: <span class="string">&#x27;I&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// [ [&quot;love&quot;, &quot;orange&quot;], [&quot;user&quot;, &quot;I&quot;] ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj));</span><br></pre></td></tr></table></figure><h3 id="4-String-padding"><a href="#4-String-padding" class="headerlink" title="4. String padding"></a>4. String padding</h3><p>在指定位置使用空格填充字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// padStart</span></span><br><span class="line"><span class="string">&#x27;orange&#x27;</span>.padStart(<span class="number">10</span>); <span class="comment">// &quot;    orange&quot;</span></span><br><span class="line"><span class="comment">// padEnd</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>.padEnd(<span class="number">10</span>) <span class="string">&quot;orange    &quot;</span></span><br></pre></td></tr></table></figure><h2 id="Es9"><a href="#Es9" class="headerlink" title="Es9"></a>Es9</h2><h3 id="1-异步并发"><a href="#1-异步并发" class="headerlink" title="1. 异步并发"></a>1. 异步并发</h3><p>运行 await 和 for…of 联合使用，并发执行异步操作，说实话这功能是真的鸡肋：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 逻辑处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Promise-finally"><a href="#2-Promise-finally" class="headerlink" title="2. Promise.finally()"></a>2. Promise.finally()</h3><p>无论 Promise 成功与否都会去执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then().catch(<span class="function"><span class="params">e</span> =&gt;</span> e).finally();</span><br></pre></td></tr></table></figure><h2 id="Es10"><a href="#Es10" class="headerlink" title="Es10"></a>Es10</h2><h3 id="1-Array-prototype-flat-和-Array-prototype-flatMap"><a href="#1-Array-prototype-flat-和-Array-prototype-flatMap" class="headerlink" title="1. Array.prototype.flat() 和 Array.prototype.flatMap()"></a>1. Array.prototype.flat() 和 Array.prototype.flatMap()</h3><p>作用都一样都是用于将数组展开，但不同的是两个实现方式。<code>flatMap()</code>方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组，而<code>flat()</code>方法创建一个新数组，其中所有子数组元素都以递归方式连接到该数组中，直到达到指定的深度为止。所以从实现方式来看<code>flatMap()</code>的效率更快。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.flat());</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> x));</span><br></pre></td></tr></table></figure><h3 id="2-String-trimStart-和-String-trimEnd"><a href="#2-String-trimStart-和-String-trimEnd" class="headerlink" title="2. String.trimStart() 和 String.trimEnd()"></a>2. String.trimStart() 和 String.trimEnd()</h3><p>去除字符串首位空格，用处也不会有太大，个别情况下才会进行使用。</p><h2 id="ES11"><a href="#ES11" class="headerlink" title="ES11"></a>ES11</h2><h3 id="1-globalThis"><a href="#1-globalThis" class="headerlink" title="1. globalThis"></a>1. globalThis</h3><p>获取全局的 this 对象：</p><ul><li>浏览器：window</li><li>worker：self</li><li>node：global</li></ul><p>可能由于是近期推出的，至今都没有使用过。</p><h2 id="ES12"><a href="#ES12" class="headerlink" title="ES12"></a>ES12</h2><h3 id="1-replaceAll"><a href="#1-replaceAll" class="headerlink" title="1. replaceAll"></a>1. replaceAll</h3><p>将字符串中的指定字符替换，返回新的字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line"><span class="comment">// range</span></span><br><span class="line">str.replaceAll(<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="2-数字分隔符"><a href="#2-数字分隔符" class="headerlink" title="2. 数字分隔符"></a>2. 数字分隔符</h3><p>数字之间的间隔字符串，通过 _ 分割数字，可以添加数字的可读性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> money = <span class="number">1_000_000_000</span>;</span><br><span class="line"><span class="comment">// 作用是一样的</span></span><br><span class="line"><span class="keyword">const</span> money = <span class="number">1000000000</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;自 2015 年推出 ES6 规则之后，每个一年几乎都会推出一些新增的特性，这些特性能为开发过程中提供许多的帮助，下面简单总结下自 Es6(2015) ~ Es12(2021) 推出的新特性，当然之后记录比较常用的，那些不常用的使用时再去查询也不迟。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://bipch.cn/categories/JavaScript/"/>
    
    
    <category term="ES6" scheme="https://bipch.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Github主页美化</title>
    <link href="https://bipch.cn/use-github-styles/"/>
    <id>https://bipch.cn/use-github-styles/</id>
    <published>2021-03-10T05:22:15.000Z</published>
    <updated>2021-03-10T09:20:57.380Z</updated>
    
    <content type="html"><![CDATA[<p>Github 默认展示仓库和提交信息等字段，却没有汇总或一些自定义连接功能，不过其提供了创建同名仓库的形式自定义主页。比如我的用户名为 bpc99，那么我们只需新建一个相同名的仓库即可。下面便通过此仓库中的 README 文件，自定义 Github 的主页。<br>那么 README 能玩出什么花样呢？</p><span id="more"></span><h2 id="装修效果"><a href="#装修效果" class="headerlink" title="装修效果"></a>装修效果</h2><p>首先贴出本人的个人主页修改后的样式：</p><p><img data-src="https://img.bipch.cn/2021/03/10/627185a4aa616.png" alt=""></p><h2 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h2><p>最上面中的数据统计和评分都是依靠外部的一个服务，我们只需要调用相应服务即可：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;https://github-readme-stats.vercel.app/api?username=bpc99&amp;show_icons=true&quot;</span> <span class="attribute">alt</span>=<span class="string">&quot;logo&quot;</span> <span class="attribute">height</span>=<span class="string">&quot;160&quot;</span> <span class="attribute">align</span>=<span class="string">&quot;right&quot;</span> <span class="attribute">style</span>=<span class="string">&quot;margin: 5px; margin-bottom: 20px;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>当然需要把上面的<code>username</code>字段修改为自己 Github 的用户名，这样才能正确的统计自己本人的仓库信息。</p><h2 id="自动更新博客列表"><a href="#自动更新博客列表" class="headerlink" title="自动更新博客列表"></a>自动更新博客列表</h2><p>例如上面最终展示的 5 条最先的文章，并不是写死的，而是由 Github 每个一段时间自动统计文章中最新的 5 篇。<br>当然如果你也需要该功能，可以将 README 添加下面的代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## Latest Blog Posts</span></span><br><span class="line"></span><br><span class="line">&lt;!-- BLOG-POST-LIST:START --&gt;</span><br><span class="line">&lt;!-- BLOG-POST-LIST:END --&gt;</span><br></pre></td></tr></table></figure><p>其实只是一个标题，和一些代码的注释声明，之后 Github 统计的数据会自动统计到注释代码块中，也就是<code>可以通过修改注释的位置，可以将其放置到任意位置</code>。<br>当然我们还需要实现一个<code>每段时间自动统计的功能</code>，该功能才是重中之重，我们需要 Github 的 Github Action 来进行实现。</p><p>点击下面的按钮，可进行添加操作：</p><p><img data-src="https://img.bipch.cn/2021/03/10/3740e196f980b.png" alt=""></p><p>然后我们将下面内容粘贴进去：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Blog</span> <span class="string">Posts</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="comment"># Run workflow automatically</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="comment"># Runs every hour, on the hour</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">&quot;0 * * * *&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">update-readme-with-blog:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Update</span> <span class="string">this</span> <span class="string">repo&#x27;s</span> <span class="string">README</span> <span class="string">with</span> <span class="string">latest</span> <span class="string">blog</span> <span class="string">posts</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">gautamkrishnar/blog-post-workflow@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># comma-separated list of RSS feed urls</span></span><br><span class="line">          <span class="attr">feed_list:</span> <span class="string">&quot;https://bipch.cn/atom.xml&quot;</span></span><br></pre></td></tr></table></figure><p>当然上面的<code>cron: &quot;0 * * * *&quot;</code>表示多长时间执行一次，这里为每小时 0 分的时候去执行，所以执行整点我们才能看到结果，当然事件可能有几分钟的延迟，所以耐心等待一段时间即可。<br>另一个关键的字段为<code>feed_list</code>文章的 RSS 订阅地址，多个的话后面使用逗号分割，所以使用该功能一定要拥有文章的 RSS 地址，如果并没有或者忘记都不能使用该功能，由于本人博客是使用 Hexo 生成的，所以根据文章生成 RSS 非常简单，当然如果是其它的肯定也有方法，根据技术的不同，生成的方式也不会相同，这里就不多叙述了，大家可以去网上查阅。</p><h2 id="完整源代码"><a href="#完整源代码" class="headerlink" title="完整源代码"></a>完整源代码</h2><p>当然上面只是一些简单的功能，但是其是 Mackdown 类型的文档，我们可以任意添加一些自己需要的代码。</p><p>最后贴出本人的仓库地址：<a href="https://github.com/bpc99/bpc99">https://github.com/bpc99/bpc99</a></p><p>大家也可以根据自己需求去添加，最后祝大家都有一个高大上的 Github 主页。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Github 默认展示仓库和提交信息等字段，却没有汇总或一些自定义连接功能，不过其提供了创建同名仓库的形式自定义主页。比如我的用户名为 bpc99，那么我们只需新建一个相同名的仓库即可。下面便通过此仓库中的 README 文件，自定义 Github 的主页。&lt;br&gt;那么 README 能玩出什么花样呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Github" scheme="https://bipch.cn/categories/Github/"/>
    
    
    <category term="美化" scheme="https://bipch.cn/tags/%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>pm2 + Nginx 部署 Koa2</title>
    <link href="https://bipch.cn/pm2-nginx/"/>
    <id>https://bipch.cn/pm2-nginx/</id>
    <published>2021-01-30T18:10:03.000Z</published>
    <updated>2021-08-25T08:11:53.013Z</updated>
    
    <content type="html"><![CDATA[<p>因为自己需要空闲的时候总结一些个人项目等，之前通过 <a href="https://hexo.io/zh-cn/">hexo</a> 搭建的博客，但是接触了 koa2 决定使其搭建一个后台接口服务，为前端界面提供相应数据。<br>本篇主要讲解客户端一键将 koa2 项目部署到服务器，服务器端使用 pm2 管理 koa2 服务及 Nginx 反向代理服务到另一个接口。<br>首先网站大致为：koa2 默认占用本地 <code>6060</code> 端口，然后通过 nginx 反向代理到 <code>80</code> 端口，同时 nginx 将 <code>80</code> 端口转发到 <code>443</code> 强制使用 https 协议。</p><span id="more"></span><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>本人服务器系统为 <code>CentOS7.0</code>，系统不同执行的命令也会有些许差别。部署之前要安装必备的软件：<code>Node</code>、<code>npm</code>、<code>pm2</code>、<code>Nginx</code>、<code>MongoDB</code>。安装的方法这里就不多说了，方式有太多。<br><strong>下面的配置都是为了服务器安全，如果不需要可以不用配置。后面用户直接设置为 root 即可</strong>。</p><h3 id="创建新用户-可选"><a href="#创建新用户-可选" class="headerlink" title="创建新用户(可选)"></a>创建新用户(可选)</h3><p>为了服务器的安全起见，不推荐用 root 用户管理所有权限，只有需要 root 权限时，在使用 <code>su</code> 命令切换为 root 用户。<br>首先创建一个新用户进行管理：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">useradd lucifer</span></span><br></pre></td></tr></table></figure><p>对新用户初始化密码：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">passwd lucifer</span></span><br></pre></td></tr></table></figure><p>将该用户添加到 <code>wheel</code> 组中，设置为管理员用户：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">usermod -aG wheel lucifer</span></span><br></pre></td></tr></table></figure><h3 id="文件读写权限-可选"><a href="#文件读写权限-可选" class="headerlink" title="文件读写权限(可选)"></a>文件读写权限(可选)</h3><p>因为我们自定义了用户进行管理，其并不会向 root 一样有着所有文件的读写权限，我们需要对指定路径设置新用户的访问权限。<br>比如我在服务器中将最终代码放置在 <strong>/var/api/blog</strong> 路径下，那么我们通过下面方式分配权限：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R lucifer <span class="regexp">/var/</span>api</span><br><span class="line">chmod -R <span class="number">755</span> <span class="regexp">/var/</span>api</span><br></pre></td></tr></table></figure><p>使用 <code>chown</code> 命令分配指定用户权限，使用 <code>chmod</code> 分配给文件夹详细权限(755表示拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限)。</p><h2 id="SSH-上传代码"><a href="#SSH-上传代码" class="headerlink" title="SSH 上传代码"></a>SSH 上传代码</h2><p>客户和服务器端同步代码需要建立一个 github 的私人仓库，我的命名为 react_blog_api。</p><h3 id="设置密钥"><a href="#设置密钥" class="headerlink" title="设置密钥"></a>设置密钥</h3><p>由于需要使用 ssh 读写私人仓库内容，所以需要配置私人仓库中的 <strong>Deploy keys</strong>。这就需要我们在客户端和服务器端生成 <code>id_rsa.pub</code>(默认名称)文件，并查询其内容：<br>首先我们查看是否已经生成该文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~<span class="regexp">/.ssh/i</span>d_rsa.pub  <span class="comment"># cat 命令查看文件</span></span><br></pre></td></tr></table></figure><p>当然如果 <code>cat</code> 命令没有查找文件，那么可以使用下面命令生成：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">&quot;你的个人邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>复制成功后，将内容粘贴到 github 中的 SSH keys 中：<br><img data-src="https://cdn.bplink66.com/2021/08/25/1m0epegcjh3.png" alt=""></p><h3 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h3><p>私人仓库配置完成后，我们便有权限操作私人仓库了，我们将客户端代码传入到仓库中：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> init</span><br><span class="line"><span class="symbol">git</span> remote <span class="keyword">add</span> origin https:<span class="comment">//github.com/bpc99/blog_api.git</span></span><br><span class="line"><span class="symbol">git</span> <span class="keyword">add</span> .</span><br><span class="line"><span class="symbol">git</span> commit -m <span class="string">&quot;项目初始化&quot;</span></span><br><span class="line"><span class="symbol">git</span> <span class="keyword">push</span> -u origin master</span><br></pre></td></tr></table></figure><p>这样便将客户端代码提交至 Github 私人仓库。</p><h2 id="pm2-配置"><a href="#pm2-配置" class="headerlink" title="pm2 配置"></a>pm2 配置</h2><p>使用 pm2 可以使 node 程序永远保持活动状态，无需停机便可以重新加载它们，并简化常见的任务管理。并且其还为我们提供了 deploy 配置，可以让我们在本地一键将项目部署到服务端。</p><h3 id="同步代码"><a href="#同步代码" class="headerlink" title="同步代码"></a>同步代码</h3><p>关于 pm2 的基本操作和配置这里就不介绍了，具体可以查看其 <a href="https://github.com/Unitech/pm2">官方文档</a>，当 koa2 本地运行无误时，我们需要配置 pm2 中的 <code>deploy</code>属性，其默认的模板文件为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">apps</span> : [...],</span><br><span class="line">  <span class="attr">deploy</span> : &#123;</span><br><span class="line">    <span class="attr">production</span> : &#123;</span><br><span class="line">      <span class="attr">user</span> : <span class="string">&quot;node&quot;</span>,</span><br><span class="line">      <span class="attr">host</span> : <span class="string">&quot;47.110.125.228&quot;</span>,</span><br><span class="line">      <span class="attr">ref</span>  : <span class="string">&quot;origin/master&quot;</span>,</span><br><span class="line">      <span class="attr">repo</span> : <span class="string">&quot;git@github.com:repo.git&quot;</span>,</span><br><span class="line">      <span class="attr">path</span> : <span class="string">&quot;/var/www/production&quot;</span>,</span><br><span class="line">      <span class="string">&quot;post-deploy&quot;</span> : <span class="string">&quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些基础的配置，其各个属性也都很简单：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;production&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;user&quot;</span>: <span class="string">&quot;登录远程服务器的用户名(例如 root)&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;host&quot;</span>: <span class="string">&quot;IP&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;ref&quot;</span>: <span class="string">&quot;远端名称及分支名&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;repo&quot;</span>: <span class="string">&quot;git仓库地址&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;远程服务器部署目录，需要填写user具备写入权限的目录&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;post-deploy&quot;</span> : <span class="string">&quot;部署后需要执行的命令&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们根据自己服务器的信息填入即可，最后贴出本人的配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">apps</span> : [...],</span><br><span class="line">  <span class="attr">production</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: <span class="string">&quot;bpc&quot;</span>,</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;47.110.125.228&quot;</span>,</span><br><span class="line">    <span class="attr">ref</span>: <span class="string">&quot;origin/master&quot;</span>,</span><br><span class="line">    <span class="attr">repo</span>: <span class="string">&quot;git@github.com:bpc99/blog_api.git&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/var/api/blog&quot;</span>,</span><br><span class="line">    <span class="string">&quot;post-deploy&quot;</span>: <span class="string">&quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样便完成了 pm2 的基本配置，贴出 <code>ecosystem.config.js</code> 所有配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">apps</span>: [&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;api&#x27;</span>,</span><br><span class="line">    <span class="attr">script</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">watch</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">ignore_watch</span>: [ <span class="string">&quot;node_modules&quot;</span> ]</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="attr">deploy</span>: &#123;</span><br><span class="line">    <span class="attr">production</span>: &#123;</span><br><span class="line">      <span class="attr">user</span>: <span class="string">&quot;bpc&quot;</span>,</span><br><span class="line">      <span class="attr">host</span>: <span class="string">&quot;47.110.125.228&quot;</span>,</span><br><span class="line">      <span class="attr">ref</span>: <span class="string">&quot;origin/master&quot;</span>,</span><br><span class="line">      <span class="attr">repo</span>: <span class="string">&quot;git@github.com:bpc99/blog_api.git&quot;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/var/api/blog&quot;</span>,</span><br><span class="line">      <span class="string">&quot;post-deploy&quot;</span>: <span class="string">&quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后我们在根目录下，以 <code>ecosystem.config.js</code> 为配置文件，启动 pm2：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy ecosystem.config.js production setup</span><br></pre></td></tr></table></figure><p>此时会出现一个错误：</p><blockquote><p>Host key verification failed.<br>fatal: Could not read from remote repository.</p></blockquote><p>主要是因为在远程服务器中，并未将 <a href="https://github.com">github.com</a> 加入known_hosts，在服务器端通过如下命令设置：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keyscan -t rsa github.com &gt;&gt; ~<span class="regexp">/.ssh/</span>known_hosts</span><br></pre></td></tr></table></figure><p>如果成功，会在<strong>/home/用户名/.ssh</strong>目录下生成<code>known_hosts</code>文件。然后客户端重新执行部署的指令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy ecosystem.config.js production setup</span><br></pre></td></tr></table></figure><p>如果传输成功 pm2 便将 GitHub 私人仓库中的文件，都传输到了我们服务器指定路径下，我们打开指定文件夹，发现其多了 3 个文件夹：</p><ul><li><code>current</code>：当前运行的文件夹。</li><li><code>source</code>：真正的项目源代码。</li><li><code>shared</code>：项目日志文件。</li></ul><h3 id="部署代码"><a href="#部署代码" class="headerlink" title="部署代码"></a>部署代码</h3><p>当一键传输配置完成，客户端项目代码可以一键传输到服务器上，这样我们便可以开始部署服务器上的项目了。<br>在开始部署之前，我们需要确保本地和 Github 私人仓库代码的同步，先将本地文件同步到 Github：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 和仓库代码同步</span></span><br><span class="line">git pull</span><br><span class="line"><span class="meta"># 代码添加到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta"># 提交暂存区到仓库区</span></span><br><span class="line">git commit -m <span class="string">&quot;update ecosystem&quot;</span></span><br><span class="line"><span class="meta"># 传本地指定分支到远程仓库</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>这样提交完成后，在本地的根目录下执行命令，将代码向生产环境下部署：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy ecosystem<span class="selector-class">.config</span><span class="selector-class">.js</span> production</span><br></pre></td></tr></table></figure><p>如果项目部署成功，配置文件中的 <code>post-deploy</code> 中的命令会自动执行(当然运行速度慢了可以将 npm 切换为 cnpm 或 yarn)，那么便可以看出 pm2 给出的提示：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">PM2</span>][<span class="symbol">WARN</span>] <span class="symbol">Applications</span> api not running, starting...</span><br><span class="line">[<span class="symbol">PM2</span>][<span class="symbol">WARN</span>] <span class="symbol">Environment</span> [production] is not defined in process file</span><br><span class="line">[<span class="symbol">PM2</span>] <span class="symbol">App</span> [api] launched (<span class="number">1</span> instances)</span><br><span class="line">┌─────┬────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐</span><br><span class="line">│ id  │ name   │ namespace   │ version │ mode    │ pid      │ uptime │ ?    │ status    │ cpu      │ mem      │ user     │ watching │</span><br><span class="line">├─────┼────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤</span><br><span class="line">│ <span class="number">0</span>   │ api    │ default     │ <span class="number">1.0</span><span class="number">.0</span>   │ fork    │ <span class="number">9438</span>     │ <span class="number">0</span>s     │ <span class="number">0</span>    │ online    │ <span class="number">0</span><span class="comment">%       │ 9.1mb    │ bpc      │ disabled │</span></span><br><span class="line">└─────┴────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘</span><br><span class="line">  ○ successfully deployed origin/master</span><br><span class="line">--&gt; <span class="symbol">Success</span></span><br></pre></td></tr></table></figure><p>这样便表示代码部署成功，我们可以在服务器上所有端口使用清空：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -antp<span class="string">|grep</span></span><br></pre></td></tr></table></figure><p>可以查看端口开发情况，例如本人的6060端口：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tcp</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">127.0.0.1:6060</span>    <span class="number">0.0.0.0</span>:*    LISTEN    <span class="number">2657</span>/node /var/www/</span><br></pre></td></tr></table></figure><p><code>注意</code>：此时端口为<strong>127.0.0.1</strong>表明局域网可以访问，公网是不能访问到的，我们还需要 nginx 进行代理。</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>上面基本运行完成，但是只有局域网可以访问，我们需要将其使用 nginx 代理至公网上，至于 nginx 下载和配置便不多提了，我们可以新建一个配置文件，最终贴出我的配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">server_name</span> api.bipch.cn;</span><br><span class="line">  <span class="attribute">access_log</span>  /www/wwwlogs/api.bipch.cn.log;</span><br><span class="line">  <span class="attribute">error_log</span>  /www/wwwlogs/api.bipch.cn.<span class="literal">error</span>.log;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host $http_host;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-NginX-Proxy <span class="literal">true</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:6060;</span><br><span class="line">    <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其原理也很简单，其拦截了<strong>80</strong> 端口，并代理到本地的 <strong>6060</strong>，并配置了相应的域名，日志，端口等信息，配置完成后，使用 <code>./nginx -s reload</code> 重启服务。<br>最后如果配置正确，并且相应端口的安全组已经打开，那么我们便可以正常访问相应的 API 了。</p><h3 id="配置-https"><a href="#配置-https" class="headerlink" title="配置 https"></a>配置 https</h3><p>Nginx 配置 Https 并免费通过阿里云申请证书， <a href="/nginx-https">前一篇文章</a> 中已经介绍了，这里就不多说了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为自己需要空闲的时候总结一些个人项目等，之前通过 &lt;a href=&quot;https://hexo.io/zh-cn/&quot;&gt;hexo&lt;/a&gt; 搭建的博客，但是接触了 koa2 决定使其搭建一个后台接口服务，为前端界面提供相应数据。&lt;br&gt;本篇主要讲解客户端一键将 koa2 项目部署到服务器，服务器端使用 pm2 管理 koa2 服务及 Nginx 反向代理服务到另一个接口。&lt;br&gt;首先网站大致为：koa2 默认占用本地 &lt;code&gt;6060&lt;/code&gt; 端口，然后通过 nginx 反向代理到 &lt;code&gt;80&lt;/code&gt; 端口，同时 nginx 将 &lt;code&gt;80&lt;/code&gt; 端口转发到 &lt;code&gt;443&lt;/code&gt; 强制使用 https 协议。&lt;/p&gt;</summary>
    
    
    
    <category term="项目部署" scheme="https://bipch.cn/categories/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="pm2" scheme="https://bipch.cn/tags/pm2/"/>
    
  </entry>
  
  <entry>
    <title>Next.js</title>
    <link href="https://bipch.cn/next/"/>
    <id>https://bipch.cn/next/</id>
    <published>2021-01-27T15:29:22.000Z</published>
    <updated>2021-11-09T15:30:17.233Z</updated>
    
    <content type="html"><![CDATA[<p>一款使用 React 开发的服务端渲染框架，<a href="https://github.com/vercel/next.js">社区</a> 的活跃度也是非常高，支持静态和服务端渲染两种方式，以及 TS、智能化打包、 路由预取等功能并无需任何配置。如果你需要搭建一个 SSR 类型项目(如个人博客、个人图库)，那么其是个首选框架。</p><span id="more"></span><h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>将组件或页面由服务端解析，服务端请求数据并填充得到最终的 html 字符串返回客户端。<br>这样做优势在于：</p><ol><li>利于SEO：平常界面信息都是通过客户端 JS 动态拼接生成的，需要服务端返回相应的数据才能正确显示，但浏览器爬虫并不会等界面完全加载之后才会抓取。而服务端渲染则更便于爬虫抓取整个网页的信息。</li><li>前端资源占用较少：因为服务端渲染完全由服务端返回客户端 HTML 字符串，客户端不再需要另外解析文件，这样前端消耗资源更少。</li><li>安全性较高：由于界面的所有信息都是服务端拼接而成，所以界面不会太多敏感信息。</li></ol><p>当然其也不是全是优点，缺点也非常多：</p><ol><li>服务器压力大：本来属于客户端的工作，现在统一交给服务端去做，如果出现高并发会对服务器造成不小负担。</li><li>首屏加载速度较慢：由于解析大部分文件都需要首屏进行加载，所以首次加载会比较慢的，并且界面跳转由于都靠后台解析界面，所以可能会出现暂时的白屏界面。</li></ol><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>空文件下安装开发闭包插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add next react react-dom</span><br></pre></td></tr></table></figure><p>修改 <code>package.json</code> 中的命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;next&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: <span class="string">&quot; next build&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;next start&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 个命令每个都有着自己作用，后面会介绍，新建一个文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home;</span><br></pre></td></tr></table></figure><p>执行 <code>yarn dev</code> 运行项目，运行成功后，直接输入： <a href="http://localhost:3000/home">http://localhost:3000/home</a> 即可访问界面，不需再需要路由相关的封装，根据约定 <code>page</code> 下的所有文件都会自动创建路由。</p><h2 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h2><p>由于其是在服务端进行预渲染，所以和以前开发方式会显得略有不同。</p><h3 id="Pages"><a href="#Pages" class="headerlink" title="Pages"></a>Pages</h3><p>代表用户看到的界面，其后缀名可以为 <code>.js</code>、<code>.jsx</code>、<code>.ts</code>、<code>.tsx</code>，但是无论何种文件，其导出内容必须为 React 组件; 并且项目中所有 page 必须放到 <code>/pages</code> 目录下，项目会自动根据位置生成路由，具体路由生成规则可以看下文的 <a href="#路由">路由</a>。</p><blockquote><p>比如界面地址为 <code>/pages/user/index.js</code>，那么它的访问路径便为 <code>/user</code>，不在需要 react-router-dom。</p></blockquote><h4 id="两种预渲染"><a href="#两种预渲染" class="headerlink" title="两种预渲染"></a>两种预渲染</h4><p>界面在 Next 中界面有两种预渲染的方式：<code>静态生成</code> 和 <code>服务器端渲染</code>。</p><ul><li><strong>静态生成</strong>：也是官网比较推荐的，在我们 build 时便生成 html 文件(build 时会去 request 接口，最终形成一些静态的 html 界面)。</li><li><strong>服务器端渲染</strong>：只有请求界面时才去 request 后台 API，然后重写生成 HTML 文件。</li></ul><p>我们使用 page 时一定要注意调用 API 的时机，并且 <strong>我们每个界面都可以选择一个渲染的方式</strong>。<br>在选择 page 具体使用那些渲染方式时，界面性能一定是不可忽视的一部分，而 <strong>静态生成界面的性能远高于服务器端渲染</strong>，所以除非有些特殊情况否则推荐静态生成方式渲染，其配合 CDN 缓存，将带给用户带来很好的体验。</p><h4 id="静态生成"><a href="#静态生成" class="headerlink" title="静态生成"></a>静态生成</h4><p>此方式也是 Next 官网推荐的一种方式，我们在 build 时根据 page 为模板，可以生成一系列的 html 界面，并配合 CDN 缓存，可以很大幅度提升浏览器的加载速度，因为最终结果只是些静态界面，并配合缓存，性能很难不上去。<br>静态生成界面也有两种形式:</p><ol><li>第一种是纯静态界面，界面信息都是纯静态信息，不涉及获取数据。此时 Next 构建时为每个页面生成一个 HTML 文件即可(不介绍)。</li><li>界面需要获取数据，根据数据动态生成界面。</li></ol><p>界面获取数据进行预渲染。也有两种情况，一种或两种都可能适用。在每种情况下，您都可以使用 Next.js 提供的特殊功能：</p><ol><li>界面 <strong>内容</strong> 取决于外部数据，使用 <code>getStaticProps</code>。</li><li>界面 <strong>paths 路径</strong> 取决于外部数据，使用 <code>getStaticPaths</code>(通常需要 <code>getStaticProps</code> 配合)。</li></ol><h5 id="内容取决于外部数据"><a href="#内容取决于外部数据" class="headerlink" title="内容取决于外部数据"></a>内容取决于外部数据</h5><p>例如我们有个博客系统，首页需展示博文列表：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Blog</span>(<span class="params">&#123; posts &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;posts.map((post) =&gt; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;post.title&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      ))&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Blog</span><br></pre></td></tr></table></figure><p>我们导出了一个 React 组件，其需要一个 posts 作为数据，而此数据是 request API 得到。Next.js 则会允许从同一文件 <code>export</code> 一个名为 <code>getStaticProps</code> 的 <code>async</code> 函数。该函数在构建时被调用，并允许你在预渲染时将获取的数据作为 <code>props</code> 参数传递给页面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Blog</span>(<span class="params">&#123; posts &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Render posts...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建时被调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStaticProps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用外部 API 获取博文列表</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://.../posts&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> res.json()</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      posts</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Blog</span><br></pre></td></tr></table></figure><p>注意其只会把 <code>props</code> 内的数据传递给组件，其他一律接收不到。</p><h5 id="路径取决于外部数据"><a href="#路径取决于外部数据" class="headerlink" title="路径取决于外部数据"></a>路径取决于外部数据</h5><p>此功能需要结合动态路由使用，我们可以创建一个名为 <code>pages/posts/[id].js</code> 的文件用以展示以 <code>id</code> 标识的单篇博客文章。<br>比如我们有 id 为 [1, 2, 3, 4] 的博客，那么如果我们需要为每个 id 都生成详情界面，此时预渲染的页面 <strong>paths(路径)</strong> 取决于外部数据。为了解决这个问题，Next.js 允许你从动态页面中 <code>export</code> 一个名为 <code>getStaticPaths</code> 的 <code>async</code> 函数。该函数在构建时被调用，并允许你指定要预渲染的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建时被调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStaticPaths</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用外部 API 获取博文列表</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://.../posts&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> res.json()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 据博文列表生成所有需要预渲染的路径</span></span><br><span class="line">  <span class="keyword">const</span> paths = posts.map(<span class="function">(<span class="params">post</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">params</span>: &#123; <span class="attr">id</span>: post.id &#125;,</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fallback: 其他路径是否 404</span></span><br><span class="line">  <span class="keyword">return</span> &#123; paths, <span class="attr">fallback</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们便给所有 id 构建了一个界面，当然我们还需要导出 <code>getStaticProps</code> 方法，用于根据 id 获取每页的数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Post</span>(<span class="params">&#123; post &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Render post...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStaticPaths</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在构建时也会被调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStaticProps</span>(<span class="params">&#123; params &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// params 包含此片博文的 `id` 信息。</span></span><br><span class="line">  <span class="comment">// 如果路由是 /posts/1，那么 params.id 就是 1</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">`https://.../<span class="subst">$&#123;params.id&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">const</span> post = <span class="keyword">await</span> res.json()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 props 参数向页面传递博文的数据</span></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">props</span>: &#123; post &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Post</span><br></pre></td></tr></table></figure><h4 id="服务器端渲染"><a href="#服务器端渲染" class="headerlink" title="服务器端渲染"></a>服务器端渲染</h4><p>此方式也称之为 <code>SSR</code>，主要 <strong>使用服务端进行渲染</strong>，在 <strong>每次页面请求时</strong> 都重新生成 HTML 返回。<br>如需此方式渲染，你需要 <code>export</code> 一个名为 <code>getServerSideProps</code> 的 <code>async</code> 函数。服务器将在每次页面请求时调用此函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params">&#123; data &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Render data...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getServerSideProps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Fetch data from external API</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">`https://.../data`</span>)</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> res.json()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pass data to the page via props</span></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">props</span>: &#123; data &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Page</span><br></pre></td></tr></table></figure><p>这样每次请求界面都会去执行，并数据传递的方式和 <code>getStaticProps</code> 非常的相似。不同就是 <code>getServerSideProps</code> 只会在用户请求界面时执行，构建时不执行。</p><h4 id="使用那种方式"><a href="#使用那种方式" class="headerlink" title="使用那种方式"></a>使用那种方式</h4><p>如果有可能请尽量使用 <strong>静态生成</strong>，其配合 CDN 对界面和请求资源进行缓存，这比让服务器根据每个页面请求来渲染页面快得多。<br>而当我们只需确定：我可以在用户请求之前预先渲染此页面吗？<br>如果是，那么请使用 <strong>静态生成</strong>，比如：</p><ul><li>博客文章</li><li>帮助和文档</li><li>产品展示界面</li></ul><p>但是如果需要用户每次请求都请求 API，那么请使用 <strong>服务器端渲染</strong>。</p><h3 id="样式引入"><a href="#样式引入" class="headerlink" title="样式引入"></a>样式引入</h3><h4 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h4><p>Next.js 规定全局样式必须在 <code>pages/_app.js</code> 内引入，如果没有可以新增：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../style/styles.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新创建的 `pages/_app.js` 文件中必须有此默认的导出（export）函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params">&#123; Component, pageProps &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样样式将被用于所有的组件中，但其为了避免样式冲突，其 <strong>只能</strong> 在 <code>pages/_app.js</code> 中引入。</p><h4 id="组件级-CSS"><a href="#组件级-CSS" class="headerlink" title="组件级 CSS"></a>组件级 CSS</h4><p>虽然我们可以定义一些全局样式，但是有些样式是某些组件特有的，那么我们可以通过 <a href="https://github.com/css-modules/css-modules">CSS 模块</a> 的约定新增 <code>[name].module.css</code> 文件。<br>比如 <code>/components/</code> 目录下有个 <code>Button</code>，那么我们创建 <code>/components/Button.module.css</code>，然后我们在组件中引入样式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./Button.module.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">className</span>=<span class="string">&#123;styles.error&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    &gt;</span></span></span><br><span class="line"><span class="xml">      Destroy</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样便能使用组件级的 CSS 了。</p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>Next.js 规定为 <code>pages</code> 下所有文件生成路由，路由的地址取决于界面相对与 pages 的路径，并会寻找文件夹下的 index 文件。比如：</p><ul><li><code>/pages/index.js</code> 路径为 <code>/</code></li><li><code>/pages/blog/index.js</code> 路径为 <code>/blog</code></li><li><code>/pages/blog/first-post.js</code> 路径为 <code>/blog/first-post</code></li></ul><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>除了上面方式的路由，有时我们还需要更高级的路由，比如界面需要外部界面通过 param 方式传入的 id，那么我们可将文件夹名称设置为 <code>[param].js</code>。<br>比如新增 <code>/pages/post/[id].js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Post = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter();</span><br><span class="line">  <span class="keyword">const</span> &#123; id &#125; = router.query;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Post: &#123;id&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Post;</span><br></pre></td></tr></table></figure><p>这样任何像 <code>/post/1</code>、<code>/post/abc</code> 等路由都会匹配到 <code>/pages/post/[id].js</code> 文件，并将匹配到的参数发送到组件中。<br>我们还可以使用 <code>[...param]</code> 匹配后面所有字段。比如新增 <code>pages/post/[...param].js</code> 文件，那么 <code>/post</code> 后面的所有路径都会匹配到该界面，比如 <code>/post/a</code> 那么 <code>router.query</code> 就为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">&quot;param&quot;</span>: [<span class="string">&quot;a&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><p>如果路径为 <code>/post/a/b</code> 那么 <code>router.query</code> 获取到的数据为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">&quot;param&quot;</span>: [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><h3 id="界面跳转"><a href="#界面跳转" class="headerlink" title="界面跳转"></a>界面跳转</h3><p>既然路由是根据相对路径生成的，那么如果需要界面之间跳转该怎么做呢？<br>Next.js 为我们提供了两种界面跳转的方式：<br>第一种是引入 <code>Link</code> 组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">a</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Page;</span><br></pre></td></tr></table></figure><p>除了此种方式能跳转，有时候我们跳转前需要处理一些逻辑，等逻辑处理完成使用 JS 跳转，这时我们便需要 <code>useRouter</code> 了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> router.push(&#x27;/about&#x27;)&#125;&gt;</span></span><br><span class="line"><span class="xml">      Click me</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以使用 JS 控制界面跳转。</p><h3 id="浅路由"><a href="#浅路由" class="headerlink" title="浅路由"></a>浅路由</h3><p>浅路由允许您更改，但不再次运行数据获取方法的URL，包括 <code>getServerSideProps</code>，<code>getStaticProps</code>，和 <code>getInitialProps</code>。<br>而你更新的 <code>router</code> 对象中的 <code>pathname</code> 和 <code>query</code> 将会正常收到，而且界面不会刷新状态不会丢失。<br>要启用浅层路由，将 <code>shallow</code> 选项设置为 <code>true</code>。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter();</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// The counter changed!</span></span><br><span class="line">  &#125;, [router.query.counter])</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">goPage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    router.push(<span class="string">&#x27;/?counter=10&#x27;</span>, <span class="literal">undefined</span>, &#123; <span class="attr">shallow</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Page</span><br></pre></td></tr></table></figure><p>这样不修改 url 只修改传递的参数，页面不会被替换，只会更改路由的状态。<br>也可以通过配合 <code>componentDidUpdate</code> 生命周期判断组件是否需要重新渲染：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname, query &#125; = <span class="built_in">this</span>.props.router</span><br><span class="line">  <span class="comment">// verify props have changed to avoid an infinite loop</span></span><br><span class="line">  <span class="keyword">if</span> (query.counter !== prevProps.router.query.counter) &#123;</span><br><span class="line">    <span class="comment">// fetch data based on the new query</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.nextjs.cn/docs/getting-started">next.js 中文文档</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;一款使用 React 开发的服务端渲染框架，&lt;a href=&quot;https://github.com/vercel/next.js&quot;&gt;社区&lt;/a&gt; 的活跃度也是非常高，支持静态和服务端渲染两种方式，以及 TS、智能化打包、 路由预取等功能并无需任何配置。如果你需要搭建一个 SSR 类型项目(如个人博客、个人图库)，那么其是个首选框架。&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="https://bipch.cn/categories/React/"/>
    
    
    <category term="服务端渲染" scheme="https://bipch.cn/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
</feed>
